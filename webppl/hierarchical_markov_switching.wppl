/*
  This is a port of the SPPL model hierarchical-markov-switching.pynb

  Note: I'm not sure I understand the real point with the SPPL model, since it 
        includes has the p_transition and the two mu_x and mu_y in the model
        when predicting the values. The model has very nice images though. :-)
  The correspondance of the original zs and the generated Z is 92%.

  (This is a port of my Turing.jl model hierarchical_markov_switching.jl.)

  The zs array is a generated array and we compare that to the model's Z,
  this is the "correspondance" which is here 85.9%. Here I only print the
  first 13 Z values.

  ...
  Iteration: 9998 | Acceptance ratio: 0.5784
  Iteration: 9999 | Acceptance ratio: 0.5783
  expectation:
  [ [ 'separated', 0 ],
    [ 'sigma', 1.1018489073782416 ],
    [ 'p', 0.859408 ],
    [ 'z0', 0 ],
    [ 'z1', 0.012999999999999998 ],
    [ 'z2', 0.7277999999999996 ],
    [ 'z3', 1 ],
    [ 'z4', 0.9745000000000001 ],
    [ 'z5', 0.6014999999999999 ],
    [ 'z6', 0.8905 ],
    [ 'z7', 0.901 ],
    [ 'z8', 0.9482 ],
    [ 'z9', 0.7035000000000002 ],
    [ 'z10', 0.16990000000000016 ],
    [ 'z11', 0.08319999999999994 ],
    [ 'z12', 0.9333000000000001 ] ]

*/

var model = function() {
    var p_transition = [0.2, 0.8]
    var mu_x = [[5,7],
                [5,15]]
    var mu_y = [[5,8], 
                [3,8]]

    // From a simulation of the SPPL model
    var xs = [3.880793246124543, 3.5058061097812354, 7.237774689951984, 6.905669457081878, 7.995126208729154, 4.6898044637528224, 6.263190493579016, 7.278231850683178, 7.852084821649775, 5.855167322724675, 5.720088619624132, 5.391958684807007, 7.169767164696265, 6.9726298890755345, 5.1058192848261035, 7.2162584421734435, 5.978129341306567, 4.632434607148869, 7.350778010868155, 7.163199329872764, 3.312995640232463, 6.984375601895885, 7.724455510712415, 5.347415852836971, 6.9430666068360685, 6.182619378597637, 4.474288262345756, 6.39310952727029, 5.016568585393731, 3.395680248255592, 6.485147290740601, 5.3963458371627215, 4.139882819360646, 4.449201069426469, 3.6512381850843667, 5.116290730592944, 6.937674534921111, 7.0500723954996225, 9.812754469939957, 6.196020900659568, 7.0346040847010425, 6.504549077277077, 7.854425984948853, 7.205493992191783, 6.249403045244166, 4.9176270039175245, 2.4866629773701137, 4.41806051644474, 4.578169073441404, 5.554708298980772, 7.41669328653965, 6.835240203522926, 6.309709638182985, 7.420028428918369, 7.731733741224992, 7.842460992547666, 5.988555563719187, 5.691336019473092, 6.2453880266204695, 6.122901245600784, 4.809476409451023, 4.155260934607323, 5.614429568237265, 6.195549626249333, 5.640085080509843, 6.436848039947654, 7.710450159939799, 7.635502275425415, 3.854963010979329, 3.6886646377960455, 4.584214524115992, 5.024753832591269, 3.2863538125483407, 6.787303600428101, 4.770602129374909, 5.706485809946122, 5.555718053917937, 8.060446637998837, 7.737160780287548, 8.301669108932963, 6.111263452419774, 6.36317050704917, 6.831994416446748, 5.245384044497105, 4.513669998612345, 5.847666590699994, 8.009842936472989, 7.511212171510765, 6.392442074959624, 7.417459874615795, 8.44176627215282, 4.99804279054474, 7.479966948085545, 7.666437579480905, 6.973682646784251, 6.613120207032197, 6.014530091460834, 7.8888624942168715, 6.469044373467464, 8.529156359409793]
    var ys = [5.0, 6.0, 4.0, 11.0, 9.0, 7.0, 11.0, 6.0, 6.0, 9.0, 3.0, 2.0, 8.0, 10.0, 3.0, 10.0, 10.0, 7.0, 6.0, 10.0, 3.0, 8.0, 12.0, 9.0, 9.0, 8.0, 6.0, 9.0, 7.0, 8.0, 5.0, 4.0, 7.0, 7.0, 3.0, 9.0, 6.0, 13.0, 7.0, 14.0, 7.0, 8.0, 11.0, 7.0, 4.0, 6.0, 7.0, 6.0, 3.0, 5.0, 10.0, 9.0, 4.0, 9.0, 5.0, 8.0, 9.0, 2.0, 7.0, 2.0, 4.0, 2.0, 6.0, 6.0, 6.0, 4.0, 5.0, 6.0, 3.0, 3.0, 4.0, 3.0, 3.0, 5.0, 4.0, 8.0, 4.0, 9.0, 5.0, 7.0, 8.0, 5.0, 7.0, 8.0, 2.0, 5.0, 7.0, 7.0, 5.0, 4.0, 11.0, 11.0, 7.0, 8.0, 13.0, 4.0, 9.0, 7.0, 12.0, 9.0]

    // For comparison (a generated Z array)
    var zs = [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]
    var n = xs.length
    // Z = tzeros(n)

    // Note: The model use separated as an index (in mu_x and mu_y)
    var separated = flip(0.4)*1 // categorical({ps:[0.6,0.4],vs:[0,1]}) // false = 0, true = 1
    
    var sigma = uniform(0,3)
    // var sigma = 1
    
    var Z = mapN(function(i) {return flip(0.5) }, n)
    mapN(function(i) {
        // We have to convert Z[i] (false/true) to indices (0/1)
        if (i == 0) {
            observe( Bernoulli({p:0.5}), Z[0])
            observe( Gaussian({mu:mu_x[separated][Z[0]*1],sigma:sigma} ), xs[0])
            observe( Poisson({mu:mu_y[separated][Z[0]*1]}), ys[0])
        } else {
            observe( Bernoulli({p:p_transition[Z[i-1]*1]}), Z[i])
            observe( Gaussian({mu:mu_x[separated][Z[i]*1],sigma:sigma}), xs[i])
            observe( Poisson({mu:mu_y[separated][Z[i]*1]}), ys[i])
    }
    },n)
            
    // How many are the same as zs?
    var p = sum(mapN(function(i) {return zs[i] == Z[i]*1 ? 1 : 0}, n)) / n
    // Get the Z values (as 0/1)
    var z = function(i) {return Z[i]*1 }
    
    return {
        separated:separated,
        sigma:sigma,
        p:p,
        z0:z(0),
        z1:z(1),
        z2:z(2),
        z3:z(3),
        z4:z(4),
        z5:z(5),
        z6:z(6),
        z7:z(7),
        z8:z(8),
        z9:z(9),
        z10:z(10),
        z11:z(11),
        z12:z(12),
    }
}

// var d = Infer(model)
var d = Infer({method:"MCMC",kernel:"MH",samples:10000,verbose:true},model)
// var d = Infer({method:"SMC",particles:100,rejuvSteps:5},model)
// display(d)

exp_map(d,["separated","sigma","p",
           "z0","z1","z2","z3","z4","z5","z6","z7","z8","z9",
           "z10","z11","z12",
           
          ],
        ["expectation"])
