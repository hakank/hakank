var fs = require('fs');


/*
   Histogram function

   This is aliased in hakank_utils.wppl as
     histogram1(values, num_bins)
   
*/
var histogram1 = function(values,num_bins) {
    if (typeof values[0] === "number") {
        // numeric values
        var min = _.min(values)
        var max = _.max(values)
        // console.log("min:",min,"max:",max)
        var width = (max-min)/num_bins
        var bins = new Array(num_bins+1).fill(0);
        // var intervals = _.range(num_bins).map((v)=>Math.round(v*width+min))
        // Special handling of integers vs floats
        var isInt = Number.isInteger(values[0])
        var intervals = isInt ?
            _.range(num_bins).map((v)=>Math.round(v*width+min)) :
            _.range(num_bins).map((v)=>Math.round((v*width+min)*100)/100) 
        for(v of values) {
            var t = Math.ceil((v-min)/width)
            //console.log("v:",v,"t:",t,"x:",Math.round(t*width+min))
            bins[t] += 1
        }
    } else {
        // non-numeric values
        var bins = new Object()
        for(v of values) {
            if (!bins[v]) {
                bins[v] = 1
            } else {
                bins[v] += 1
            }
        }
        var intervals = Object.keys(collect(values))
    }
    return {
        bins:bins,
        intervals:intervals,
    }
    
}

/*
    Pluck values (key) from an array of dicts.

   From https://stackoverflow.com/questions/25726066/equivalent-of-underscore-pluck-in-pure-javascript
*/
var pluck = function(arr,key){
    var newArr = [];
    for (var i = 0, x = arr.length; i < x; i++){
        if (arr[i].hasOwnProperty(key)){
            newArr.push(arr[i][key])
        }
    }
    return newArr;
}

// shuffle(array)
// Returned a shuffled version of the array (permutation)
// This is Fisher-Yates Sorting Algorithm based on
// https://www.freecodecamp.org/news/how-to-shuffle-an-array-of-items-using-javascript-or-typescript/
//
// Note: It should not be used with Enumerate since it's using Math.random.
//
var shuffle = function(a) {
  for (let i = a.length - 1; i > 0; i--) { 
    const j = Math.floor(Math.random() * (i + 1)); 
    [a[i], a[j]] = [a[j], a[i]]; 
  } 
  return a; 
}

// Shuffle an array using sort
// https://www.freecodecamp.org/news/how-to-shuffle-an-array-of-items-using-javascript-or-typescript/
// This is not as reliable as shuffle() but it's interesting
/*
var shuffle2 = function(a) {
    return a.sort(() => Math.random() - 0.5);
}
*/


// From https://www.w3resource.com/javascript-exercises/javascript-math-exercise-20.php
function binomial_coeff(n, k) {
    if ((typeof n !== 'number') || (typeof k !== 'number')) 
        return false; 
    var coeff = 1;
    for (var x = n-k+1; x <= n; x++) coeff *= x;
    for (x = 1; x <= k; x++) coeff /= x;
    return coeff;
}

// From ChatGPT-3.5
function poisson_quantileJS(lambdaParameter,q) {
    if (q < 0 || q > 1) {
        throw new Error("q must be in the range [0, 1]");
    }

    let k = 0;
    let cumulativeProbability = 0;
    while (cumulativeProbability < q) {
        cumulativeProbability += Math.exp(-lambdaParameter) * Math.pow(lambdaParameter, k) / factorial(k);
        k++;
    }

    return k - 1; // Subtract 1 to get the quantile value
}

function factorial(n) {
    if (n === 0) return 1;
    let result = 1;
    for (let i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}


//
// Gaussian quantiles
// 

//
// https://stackoverflow.com/questions/12556685/is-there-a-javascript-implementation-of-the-inverse-error-function-akin-to-matl
//
// This is not very good!
function erfInv(x){
    var z;
    var a  = 0.147;                                                   
    var the_sign_of_x;
    if(0==x) {
        the_sign_of_x = 0;
    } else if(x>0){
        the_sign_of_x = 1;
    } else {
        the_sign_of_x = -1;
    }

    if(0 != x) {
        var ln_1minus_x_sqrd = Math.log(1-x*x);
        var ln_1minusxx_by_a = ln_1minus_x_sqrd / a;
        var ln_1minusxx_by_2 = ln_1minus_x_sqrd / 2;
        var ln_etc_by2_plus2 = ln_1minusxx_by_2 + (2/(Math.PI * a));
        var first_sqrt = Math.sqrt((ln_etc_by2_plus2*ln_etc_by2_plus2)-ln_1minusxx_by_a);
        var second_sqrt = Math.sqrt(first_sqrt - ln_etc_by2_plus2);
        z = second_sqrt * the_sign_of_x;
    } else { // x is zero
        z = 0;
    }
    return z;
}


//
// Via ChatGPT: Not too bad, but not impressive!
//
// Quantile[NormalDistribution[100, 15], 0.99] -> 134.895
// normalQuantile(100,15,0.99) -> 134.8613498234336
//
// Quantile[NormalDistribution[100, 15], 0.9999] -> 155.785
// normalQuantile(100,15,0.9999) -> 155.67772635407104
//
// Quantile[NormalDistribution[100, 15], 0.0001] -> 44.2148
// normalQuantile(100, 15, 0.0001) -> 44.322273645928966
//
/*
function normal_quantileJS(mu, sigma, q) {
    if (q <= 0 || q >= 1) {
        throw new Error("q should be in (0, 1)");
    }

    // Adjust q for the two-tail nature of the Gaussian distribution
    if (q > 0.5) {
        return mu + sigma * Math.sqrt(2) * erfInv(2*q - 1);
    } else {
        return mu - sigma * Math.sqrt(2) * erfInv(1 - 2*q);
    }
}
*/

/* 
  From https://stackoverflow.com/questions/8816729/javascript-equivalent-for-inverse-normal-function-eg-excels-normsinv-or-nor
  erfcinv
  erfc
  erf
  normal_quantile
  This is quite good!
*/
function erfcinv(p) {
    var j = 0;
    var x, err, t, pp;
    if (p >= 2)
      return -100;
    if (p <= 0)
      return 100;
    pp = (p < 1) ? p : 2 - p;
    t = Math.sqrt(-2 * Math.log(pp / 2));
    x = -0.70711 * ((2.30753 + t * 0.27061) /
      (1 + t * (0.99229 + t * 0.04481)) - t);
    for (; j < 2; j++) {
      err = erfc(x) - pp;
      x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
    }
    return (p < 1) ? x : -x;
}

function erfc(x) {
    return 1 - erf(x);
}

function erf(x) {
    var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
               -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
               4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
               1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
               6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
               -2.27365122e-10, 9.6467911e-11, 2.394038e-12,
               -6.886027e-12, 8.94487e-13, 3.13092e-13,
               -1.12708e-13, 3.81e-16, 7.106e-15,
               -1.523e-15, -9.4e-17, 1.21e-16,
               -2.8e-17
              ];
    var j = cof.length - 1;
    var isneg = false;
    var d = 0;
    var dd = 0;
    var t, ty, tmp, res;
    
    if (x < 0) {
        x = -x;
        isneg = true;
    }
    
    t = 2 / (2 + x);
    ty = 4 * t - 2;
    
    for (; j > 0; j--) {
        tmp = d;
        d = ty * d - dd + cof[j];
        dd = tmp;
    }
    
    res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
    return isneg ? res - 1 : 1 - res;
}

function normal_quantileJS( mean, std,p) {    
    return -1.41421356237309505 * std * erfcinv(2 * p) + mean;
}


/*
   normal_cdfJS(mean, sigma, to)
 
   From  https://stackoverflow.com/questions/5259421/cumulative-distribution-function-in-javascript
   """
   The calculation is not 100% correct as it is just a approximation.

   """
   normalcdf(30, 25, 1.4241))                        0.12651187738346226
   N[CDF[NormalDistribution[30, 25], 1.4241], 20]    0.126512

   normalcdf(100, 15, 120))                          0.9087887152305422
   N[CDF[NormalDistribution[100, 15], 120], 20]      0.90878878027413213017 

*/
function normal_cdfJS(mean, sigma, to) {
    var z = (to-mean)/Math.sqrt(2*sigma*sigma);
    var t = 1/(1+0.3275911*Math.abs(z));
    var a1 =  0.254829592;
    var a2 = -0.284496736;
    var a3 =  1.421413741;
    var a4 = -1.453152027;
    var a5 =  1.061405429;
    var erf = 1-(((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-z*z);
    var sign = 1;
    if(z < 0)
    {
        sign = -1;
    }
    return (1/2)*(1+sign*erf);
}


//
// Binomial quantile (ChatGPT)

function binomialCDF(x, n, p) {
    let binompdf = (x, n, p) => {
        if(x < 0) return 0;
        let binomialCoefficient = (n, k) => {
            if(k < 0 || k > n) return 0;
            if(k === 0 || k === n) return 1;
            k = Math.min(k, n - k);
            let res = n;
            for(let i = 2; i <= k; ++i) {
                res *= (n - i + 1);
                res /= i;
            }
            return res;
        };
        return binomialCoefficient(n, x) * Math.pow(p, x) * Math.pow(1 - p, n - x);
    };
    
    let sum = 0;
    for(let i = 0; i <= x; i++) {
        sum += binompdf(i, n, p);
    }
    return sum;
}

function binomial_quantileJS(p, n, q) {
    if(q < 0 || q > 1) {
        throw new Error("The quantile q should be between 0 and 1");
    }

    let low = 0, high = n, x;
    while(low <= high) {
        x = Math.floor((low + high) / 2);
        let cdf = binomialCDF(x, n, p);
        if(cdf < q) {
            low = x + 1;
        }
        else if(cdf > q) {
            high = x - 1;
        }
        else {
            break;
        }
    }
    
    return x;
}



//
// Geometric (ChatGPT-4)
//
function geometric_quantileJS(p, q) {
    if (q <= 0 || q >= 1) {
        throw new Error("The quantile q should be between 0 and 1");
    }

    if (p <= 0 || p >= 1) {
        throw new Error("The probability p should be between 0 and 1");
    }

    return Math.ceil(Math.log(1 - q) / Math.log(1 - p) - 1);
}


//
// Negative Binomial (ChatGPT-4)
//
function binomialCoefficient(n, k) {
    let res = 1;
    k = Math.min(k, n - k);
    for (let i = 0; i < k; ++i) {
        res *= (n - i);
        res /= (i + 1);
    }
    return res;
}

function negativeBinomialPMF(k, r, p) {
    return binomialCoefficient(k + r - 1, k) * Math.pow(p, r) * Math.pow(1 - p, k);
}

function negativeBinomialCDF(k, r, p) {
    let sum = 0;
    for (let i = 0; i <= k; i++) {
        sum += negativeBinomialPMF(i, r, p);
    }
    return sum;
}

function negative_binomial_quantileJS(r, p, q) {
    if (q < 0 || q > 1) {
        throw new Error("The quantile q should be between 0 and 1");
    }

    let k = 0;
    while (negativeBinomialCDF(k, r, p) < q) {
        k++;
    }
    return k;
}

//
// convert a list of elements into a hash with 
//   { element: number of occurrences of element, ...}
// Example:
//   var vs = hakank_utils.collect(values)
// To get the keys and values:
//   var values = sort(Object.values(vs))
//   var keys = sort(Object.keys(vs))
//
const collect = function(a) {
    let m = {};
    a.forEach(e=> {
        if (m[e] === undefined) {
            m[e] = 0;
        }
        m[e] += 1;
    })
    return m;
}

// Correlation coefficient from ChatGPT-4
// And this seems to work
function correlation_coefficientJS(array1, array2) {
  // Check if both arrays have the same length
  if (array1.length !== array2.length) {
    return 'Arrays have different lengths!';
  }
  
  var n = array1.length;
  
  var sumX = 0;
  var sumY = 0;
  var sumXY = 0;
  var sumX2 = 0;
  var sumY2 = 0;
  
  for (var i = 0; i < n; i++) {
    var x = array1[i];
    var y = array2[i];
    
    sumX += x;
    sumY += y;
    sumXY += x * y;
    sumX2 += x * x;
    sumY2 += y * y;
  }
  
  var numerator = n * sumXY - sumX * sumY;
  var denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
  
  // Check for division by zero
  if (denominator === 0) {
    return 'Denominator is zero!';
  }
  
  return numerator / denominator;
}

// https://codegolf.stackexchange.com/questions/35727/calculate-the-riemann-zeta-function
var zetaf = function(r){for(var t=0,a=1,n=1;t!=a;a=t,t+=1/Math.pow(n++,r));return t}

// See
// https://stackoverflow.com/questions/42773836/how-to-find-all-subsets-of-a-set-in-javascript-powerset-of-array
var getAllSubsets = function(a) {
  var subsets = [[]];
  for (n of a) {
    subsets.map(function(el) {
      subsets.push([...el, n])
    })
  }
  return subsets;
}

/*
  Converts an array of values into a hash table with labeled entries
  This returns a hash table:
   {
    label0:val1,
    label1:val2,
    ...
   }

   Example:
   convert_array_to_hash([10,2,31],"label")
   returns
   {
    label0:10,
    label1:2,
    label2:31
   }
    
   Use case: 
   When a model contains an array of values (e.g. [10,2,31]) and one 
   would have each of these as a separate variable in the model's 
   return hash.

   See for example urn_model_generalized.wppl for such a case.

*/
var convert_array_to_hash = function(a,label) {
    var len = a.length
    var hash = {}
    for(var i = 0; i < len; i++) {
        hash[label + "_" + i.toString()] = a[i]
    }
    return hash
}

/*
  Join hashes into a single hash.
  It is assumed that h1 and h2 does not share any keys.

  Note: The WebPPL built-in extend() seems to do exactly this:
  https://webppl.readthedocs.io/en/master/functions/other.html

     extend(h1,h2,...)

*/
/*
var join_hashes = function(h1,h2) {
    return {...h1,...h2}
}
*/
var join_hashes = function(hs) {
    var hash = {}
    for(var h of hs) {
          for(var key of Object.keys(h)) {
              hash[key] = h[key]
        }
    }
    return hash
}


// Test function
var hello = function(name) {
    return "hello, " + name
}

module.exports = {
    histogram1:histogram1,
    pluck:pluck,
    shuffle:shuffle,
    binomial_coeff:binomial_coeff,
    factorial:factorial,
    erfInv:erfInv,
    erfcinv:erfcinv,
    erfc:erfc,
    erf:erf,
    poisson_quantileJS:poisson_quantileJS,
    normal_quantileJS:normal_quantileJS,
    normal_cdfJS:normal_cdfJS,
    binomial_quantileJS:binomial_quantileJS,
    geometric_quantileJS:geometric_quantileJS,
    negative_binomial_quantileJS:negative_binomial_quantileJS,

    correlation_coefficientJS:correlation_coefficientJS,
    collect:collect,
    zetaf:zetaf,

    getAllSubsets:getAllSubsets,
    convert_array_to_hash:convert_array_to_hash,
    join_hashes:join_hashes,
    
    hello: hello,
};
