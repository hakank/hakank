var fs = require('fs');


/*
   Histogram function

   This is aliased in hakank_utils.wppl as
     histogram1(values, num_bins)
   
*/
var histogram1 = function(values,num_bins) {
    if (typeof values[0] === "number") {
        // numeric values
        var min = _.min(values)
        var max = _.max(values)
        // console.log("min:",min,"max:",max)
        var width = (max-min)/num_bins
        var bins = new Array(num_bins+1).fill(0);
        for(v of values) {
            var t = Math.ceil((v-min)/width)
            bins[t] += 1
        }
    } else {
        // non-numeric values
        var bins = new Object()
        for(v of values) {
            if (!bins[v]) {
                bins[v] = 1
            } else {
                bins[v] += 1
            }
        }
    }
    return {
        bins:bins,
    }
    
}

/*
    Pluck values (key) from an array of dicts.

   From https://stackoverflow.com/questions/25726066/equivalent-of-underscore-pluck-in-pure-javascript
*/
var pluck = function(arr,key){
    var newArr = [];
    for (var i = 0, x = arr.length; i < x; i++){
        if (arr[i].hasOwnProperty(key)){
            newArr.push(arr[i][key])
        }
    }
    return newArr;
}

// shuffle(array)
// Returned a shuffled version of the array (permutation)
// This is Fisher-Yates Sorting Algorithm based on
// https://www.freecodecamp.org/news/how-to-shuffle-an-array-of-items-using-javascript-or-typescript/
//
// Note: It should not be used with Enumerate since it's using Math.random.
//
var shuffle = function(a) {
  for (let i = a.length - 1; i > 0; i--) { 
    const j = Math.floor(Math.random() * (i + 1)); 
    [a[i], a[j]] = [a[j], a[i]]; 
  } 
  return a; 
}

// Shuffle an array using sort
// https://www.freecodecamp.org/news/how-to-shuffle-an-array-of-items-using-javascript-or-typescript/
// This is not as reliable as shuffle() but it's interesting
/*
var shuffle2 = function(a) {
    return a.sort(() => Math.random() - 0.5);
}
*/


// From https://www.w3resource.com/javascript-exercises/javascript-math-exercise-20.php
function binomial_coeff(n, k) {
    if ((typeof n !== 'number') || (typeof k !== 'number')) 
        return false; 
    var coeff = 1;
    for (var x = n-k+1; x <= n; x++) coeff *= x;
    for (x = 1; x <= k; x++) coeff /= x;
    return coeff;
}

// From ChatGPT-3.5
function poisson_quantileJS(lambdaParameter,q) {
    if (q < 0 || q > 1) {
        throw new Error("q must be in the range [0, 1]");
    }

    let k = 0;
    let cumulativeProbability = 0;
    while (cumulativeProbability < q) {
        cumulativeProbability += Math.exp(-lambdaParameter) * Math.pow(lambdaParameter, k) / factorial(k);
        k++;
    }

    return k - 1; // Subtract 1 to get the quantile value
}

function factorial(n) {
    if (n === 0) return 1;
    let result = 1;
    for (let i = 1; i <= n; i++) {
        result *= i;
    }
    return result;
}


//
// Gaussian quantiles
// 

//
// https://stackoverflow.com/questions/12556685/is-there-a-javascript-implementation-of-the-inverse-error-function-akin-to-matl
// 
function erfInv(x){
    var z;
    var a  = 0.147;                                                   
    var the_sign_of_x;
    if(0==x) {
        the_sign_of_x = 0;
    } else if(x>0){
        the_sign_of_x = 1;
    } else {
        the_sign_of_x = -1;
    }

    if(0 != x) {
        var ln_1minus_x_sqrd = Math.log(1-x*x);
        var ln_1minusxx_by_a = ln_1minus_x_sqrd / a;
        var ln_1minusxx_by_2 = ln_1minus_x_sqrd / 2;
        var ln_etc_by2_plus2 = ln_1minusxx_by_2 + (2/(Math.PI * a));
        var first_sqrt = Math.sqrt((ln_etc_by2_plus2*ln_etc_by2_plus2)-ln_1minusxx_by_a);
        var second_sqrt = Math.sqrt(first_sqrt - ln_etc_by2_plus2);
        z = second_sqrt * the_sign_of_x;
    } else { // x is zero
        z = 0;
    }
    return z;
}

//
// Via ChatGPT: Not too bad, but not impressive!
//
// Quantile[NormalDistribution[100, 15], 0.99] -> 134.895
// normalQuantile(100,15,0.99) -> 134.8613498234336
//
// Quantile[NormalDistribution[100, 15], 0.9999] -> 155.785
// normalQuantile(100,15,0.9999) -> 155.67772635407104
//
// Quantile[NormalDistribution[100, 15], 0.0001] -> 44.2148
// normalQuantile(100, 15, 0.0001) -> 44.322273645928966
//
function normal_quantileJS(mu, sigma, q) {
    if (q <= 0 || q >= 1) {
        throw new Error("q should be in (0, 1)");
    }

    // Adjust q for the two-tail nature of the Gaussian distribution
    if (q > 0.5) {
        return mu + sigma * Math.sqrt(2) * erfInv(2*q - 1);
    } else {
        return mu - sigma * Math.sqrt(2) * erfInv(1 - 2*q);
    }
}


//
// Binomial quantile (ChatGPT)

function binomialCDF(x, n, p) {
    let binompdf = (x, n, p) => {
        if(x < 0) return 0;
        let binomialCoefficient = (n, k) => {
            if(k < 0 || k > n) return 0;
            if(k === 0 || k === n) return 1;
            k = Math.min(k, n - k);
            let res = n;
            for(let i = 2; i <= k; ++i) {
                res *= (n - i + 1);
                res /= i;
            }
            return res;
        };
        return binomialCoefficient(n, x) * Math.pow(p, x) * Math.pow(1 - p, n - x);
    };
    
    let sum = 0;
    for(let i = 0; i <= x; i++) {
        sum += binompdf(i, n, p);
    }
    return sum;
}

function binomial_quantileJS(p, n, q) {
    if(q < 0 || q > 1) {
        throw new Error("The quantile q should be between 0 and 1");
    }

    let low = 0, high = n, x;
    while(low <= high) {
        x = Math.floor((low + high) / 2);
        let cdf = binomialCDF(x, n, p);
        if(cdf < q) {
            low = x + 1;
        }
        else if(cdf > q) {
            high = x - 1;
        }
        else {
            break;
        }
    }
    
    return x;
}



//
// Geometric (ChatGPT-4)
//
function geometric_quantileJS(p, q) {
    if (q <= 0 || q >= 1) {
        throw new Error("The quantile q should be between 0 and 1");
    }

    if (p <= 0 || p >= 1) {
        throw new Error("The probability p should be between 0 and 1");
    }

    return Math.ceil(Math.log(1 - q) / Math.log(1 - p) - 1);
}


//
// Negative Binomial (ChatGPT-4)
//
function binomialCoefficient(n, k) {
    let res = 1;
    k = Math.min(k, n - k);
    for (let i = 0; i < k; ++i) {
        res *= (n - i);
        res /= (i + 1);
    }
    return res;
}

function negativeBinomialPMF(k, r, p) {
    return binomialCoefficient(k + r - 1, k) * Math.pow(p, r) * Math.pow(1 - p, k);
}

function negativeBinomialCDF(k, r, p) {
    let sum = 0;
    for (let i = 0; i <= k; i++) {
        sum += negativeBinomialPMF(i, r, p);
    }
    return sum;
}

function negative_binomial_quantileJS(r, p, q) {
    if (q < 0 || q > 1) {
        throw new Error("The quantile q should be between 0 and 1");
    }

    let k = 0;
    while (negativeBinomialCDF(k, r, p) < q) {
        k++;
    }
    return k;
}

//
// convert a list of elements into a hash with 
//   { element: number of occurrences of element, ...}
// Example:
//   var vs = hakank_utils.collect(values)
// To get the keys and values:
//   var values = sort(Object.values(vs))
//   var keys = sort(Object.keys(vs))
//
const collect = function(a) {
    let m = {};
    a.forEach(e=> {
        if (m[e] === undefined) {
            m[e] = 0;
        }
        m[e] += 1;
    })
    return m;
}

// Correlation coefficient from ChatGPT-4
// And this seems to work
function correlation_coefficientJS(array1, array2) {
  // Check if both arrays have the same length
  if (array1.length !== array2.length) {
    return 'Arrays have different lengths!';
  }
  
  var n = array1.length;
  
  var sumX = 0;
  var sumY = 0;
  var sumXY = 0;
  var sumX2 = 0;
  var sumY2 = 0;
  
  for (var i = 0; i < n; i++) {
    var x = array1[i];
    var y = array2[i];
    
    sumX += x;
    sumY += y;
    sumXY += x * y;
    sumX2 += x * x;
    sumY2 += y * y;
  }
  
  var numerator = n * sumXY - sumX * sumY;
  var denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
  
  // Check for division by zero
  if (denominator === 0) {
    return 'Denominator is zero!';
  }
  
  return numerator / denominator;
}


// Test function
var hello = function(name) {
    return "hello, " + name
}

module.exports = {
    histogram1:histogram1,
    pluck:pluck,
    shuffle:shuffle,
    binomial_coeff:binomial_coeff,
    factorial:factorial,
    erfInv:erfInv,
    poisson_quantileJS:poisson_quantileJS,
    normal_quantileJS:normal_quantileJS,
    binomial_quantileJS:binomial_quantileJS,
    geometric_quantileJS:geometric_quantileJS,
    negative_binomial_quantileJS:negative_binomial_quantileJS,

    correlation_coefficientJS:correlation_coefficientJS,
    collect:collect,
    
    hello: hello,
};
