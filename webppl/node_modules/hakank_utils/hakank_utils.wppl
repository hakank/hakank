/*
    Show marginals, expectations, MAP for variables.

    Sample Usage:
        var model = function() { 
            // ...
            return {
                x:x,
                y:y,
            }
        }
        var d = Infer(model)
        exp_map(d,["x","y"]))
        exp_map(d,["x","y"],["marginals","expectation"]))

*/
var exp_map = function(d,arr,types) {
    if (types === undefined) {
        console.log("Marginals:");
        map(function(a) {console.log(a);console.log(marginalize(d, a)) }, arr);
        console.log("expectation:");
        console.log(map(function(a) { [a,expectation(marginalize(d, a))] }, arr));
        console.log("MAP:");
        console.log(map(function(a) { [a,MAP(marginalize(d, a))] }, arr));
    } else {
        if (types.includes("marginals")) {
            console.log("\nMarginals:");
            map(function(a) {console.log(a);console.log(marginalize(d, a)) }, arr);
            console.log("\n");            
        }
        if (types.includes("expectation")) {
            console.log("\nexpectation:");
            console.log(map(function(a) { [a,expectation(marginalize(d, a))] }, arr));
            console.log("\n");            
        }
        if (types.includes("MAP")) {
            console.log("\nMAP:");
            console.log(map(function(a) { [a,MAP(marginalize(d, a))] }, arr));
            console.log("\n");
        }
    }

}

/* 
   Percentiles of an array.

   Example usage:
        var model = function() {
            // ...
            return {x:x}
        }
        var d = Infer(model)
        var m = marginalize(d, "x");
        var s = m.supp;
        var ps = [0,2.5,25,50,75,97.5,100];
        var pcts = percentile(s,ps);

   From https://en.wikipedia.org/wiki/Percentile
   Using Nearest rank method
*/ 
var percentile = function(values,ps) {
    var len = values.length;
    var sorted = sort(values);
    var pcts = map(function(p) {var v = Math.ceil(len*p/100);
                                return sorted[Math.max(1,v)-1]},
                   ps);
    return pcts;
}

/*
  Show statistics for a variable (v)

  Example usage:
    var model = function() {
       // ....
       export {
         x:x,
         y:y,
       }
    }
    var d = Infer(model);
    var ps = [0,2.5,25,50,75,97.5,100]; // quantiles
    show_stats(d,"x",ps);
    show_stats(d,"y",ps);

*/
var show_stats1 = function(d,v,ps) {
    console.log("\nvar", v);
    var t = map(function(e) {
        return e.value[v]
    },d.samples);
    console.log("min:", _.min(t));
    var mean = listMean(t);
    console.log("listMean:", mean);
    console.log("max:", _.max(t));
    console.log("listVar:", listVar(t,mean));
    console.log("listStdev:", listStdev(t,mean));
    
    var pcts = percentile(t,ps);
    console.log(map2(function(e,v) {return [e,v]},ps,pcts));
}


/*
  Calculate the number of bins (for histogram)

  https://en.wikipedia.org/wiki/Histogram

*/
// Square root choice
// num_bins(L) = ceiling(sqrt(L.len)).

// Rice Rule seems to be a little better...
var num_bins = function(values) {
    return 2*Math.ceil(Math.pow(values.length,1/3));
}

/*
    Histogram of an array of values.

    Sample usage:
        var model = function() {
            // ..
            return {
                x:x,
                y:y,
            }
        }
        var d = Infer(model);
        var values = map(function(e) {
            return e.value[v]
        }, d.samples);
        var hist = histogram(values)

*/
var histogram = function(values) {
    // Calculate the number of bins
    var num_bins = num_bins(values);
    return histogram1(values,num_bins);
}


// This is to JS function in hakank_utils.js instead
// It contains the meat of the histogram function.
var histogram1 = function(d,v,ps) {
    return hakank_utils.histogram1(d,v,ps);
}


/*
   Show statistics for a variable (v)

    var model = function() {
       // ..
       return {
           x:x,
           y:y,
       }
    }
    var d = Infer(model);
    var ps = [0,2.5,25,50,75,97.5,100]; // quantiles
    show_stats(d,"x",ps);
    show_stats(d,"y",ps);


*/
var show_stats = function(d,v,ps) {
    console.log("\nvar", v);
    var t = map(function(e) {
        return e.value[v]
    },d.samples);
    
    console.log("min:", _.min(t));
    if (typeof t[0] === "number") {
        var mean = listMean(t);
        console.log("listMean:", mean);
        console.log("listVar:", listVar(t,mean));
        console.log("listStdev:", listStdev(t,mean));
    }
    console.log("max:", _.max(t));    
    var pcts = percentile(t,ps);
    console.log(map2(function(e,v) {return [e,v]},ps,pcts));

    // Histogram
    var histogram = histogram(t);
    console.log("bins:",histogram.bins);
    
}

/*
    Get samples of key from distribution Dist.

    From https://mhtess.github.io/bdappl/chapters/03-simpleModels.html
*/
var getSamples = function(Dist, key){
    return _.map(_.map(Dist.samples, "value"), key)
}

/*
    Show the credible interval of samples `mySamples  with
    the credibilit mass of `credMass`.

    Sample usage:
        var model = function() {
            // ...
            return {
                x: x,
                y: y,
            }
        }
        var c = getSamples(d, "x")
        display(credibleInterval(c, 0.93))

        or
        display(credibleInterval(getSamples(d,"x"), 0.93))


    From https://mhtess.github.io/bdappl/chapters/03-simpleModels.html

*/
var credibleInterval = function(mySamples, credMass){
    var sortedPts = sort(mySamples)
    var ciIdxInc = Math.ceil(credMass*sortedPts.length)
    var nCIs = sortedPts.length - ciIdxInc
  
    var ciWidth = map(function(i){
      sortedPts[i + ciIdxInc] - sortedPts[i]
    },_.range(nCIs))
  
    var i = _.indexOf(ciWidth, _.min(ciWidth))
    return [sortedPts[i], sortedPts[i+ciIdxInc]]
  }

/*
  Wrapper for credibleInterval

  var model = function() { 
     // ...
     return {
         x:x,
         y:y
     }
  } 
  var d = Infer(model)
  showCredibleInterval(d,"x",0.93)


*/
var showCredibleInterval = function(d, v, credMass) {
    var ci = credibleInterval(getSamples(d,v), credMass)
    console.log("Credible interval for " + v + " (" + 100*credMass + "%):",ci)
}

/*
   Another stat function

    // ...
    stat2(d,"p")


   min: 2.0086531476002376
   Stat for v: p
   min: 2.0086531476002376 mean: 10.271903813176168 max: 1941.3758492450218 stdev: 38.93330207692748

*/
var stat2 = function(d,v) {
    console.log("Stat for v:",v);
    var m = marginalize(d, v);
    var s = m.supp;
    var mean = listMean(s);
    var stdev = listStdev(s,mean);
    console.log("min:",_.min(s),"mean:",mean,"max:",_.max(s),"stdev:",stdev);
    
}


/*
  Returns a normalized vector, i.e. where the sum is 1

  simplex([1,20]) ->  
    [ 0.047619047619047616, 0.9523809523809523 ]

  This is for use with e.g. categorical({ps:simplex([1,2,3,4,5]),vs:[....]})

*/
var simplex = function(v) {
    var s = sum(v)
    return mapN(function(i) { return v[i] / s },v.length)
}


/* 
   Draw n values from array a without replacements
   Run as
     draw_without_replacements(n,a,[])
*/
var draw_without_replacement = function(n,a,res) {
    if (n == 0 || a.length == 0) {
        return res
    } else {
        var d = uniformDraw(a)
        var new_a = _.difference(a,[d])
        return draw_without_replacement(n-1,new_a, res.concat(d))
    }
}


// For testing
var hello2 = function(name) {
    return "hello " + name + " from WebPPL"
}
