/*
  From Mathematica (GeometricDistribution) 
  """
  A person is standing by a road counting cars until he sees a red one, 
  at which point he restarts the count. Simulate the counting process, assuming 
  that 20% of the cars are red:

    RandomVariate[GeometricDistribution[0.2], 20]
    -> 
     {10,0,2,0,2,10,8,4,0,0,15,4,4,1,6,1,6,1,0,0}

  Find the expected number of cars to come by before the count starts over:
    Mean[GeometricDistribution[0.2]]
    -> 4

  Find the probability of counting 10 or more cars before a red one:
    NProbability[x >= 10, x -> GeometricDistribution[0.2]]
    -> 
    0.107374

  """

  * Simulating the process:
   [ 3, 2, 0, 1, 1, 2, 8, 1, 7, 0, 3, 5, 5, 2, 4, 1, 4, 0, 0, 4 ]


  * Main model, using enumerate + maxExecutions:10000
   expectation:
   [ [ 'v', 4.000000000000001 ],
     [ 'p_at_least_10', 0.10737418240000014 ] ]

*/

// From Handbook on probability distributions
// page 19
// Expectation: (1-p)/p
// """
// A basic algorithm is to use i.i.d. Bernoulli variables as follows:
// * initialize X to 0 and generate U from an uniform distribution,
// * while U > p do ; generate U from an uniform distribution; X = X + 1;
// * return X.
// """
// var geometric1 = function(p,x) {
//     var u = uniform(0,1);
//     return u > p ? geometric1(p,x+1) : x;
// }
//
// var geometric = function(p) {
//     return geometric1(p,0);
// }

// From http://dippl.org/chapters/02-webppl.html
// We can use enumerate with this.
var geometric = function(p) {
    return flip(p) ? 0 : 1 + geometric(p)
}


var model = function() {
    var v = geometric(0.2)
    var p_at_least_10 = v >= 10

    return {
        v:v,
        p_at_least_10:p_at_least_10
    }
}

// var d = Infer({method:"rejection",samples:100000},model)
var d = Infer( {method:"enumerate",maxExecutions:10000},model)
// display(d)

exp_map(d,["v","p_at_least_10"],["expectation"])


console.log("\nSimulating the process:")
console.log(repeat(20, function() {return geometric(0.2) }))
