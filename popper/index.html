<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html> <head>
<title>My Popper page</title>
<style>
   body {
      background-color:whitesmoke;
      font: 16px Arial, sans-serif;
   }
</style>
</head>

<body>
<h1>My Popper page</h1>
Here is a collection of my Popper encodings.<br><br>
Popper is an inductive logic programming (ILP) system. For more about Popper, see <a href="https://github.com/logic-and-learning-lab/Popper">github.com/logic-and-learning-lab/Popper</a> and the paper <a href="https://arxiv.org/abs/2005.02259">Learning programs by learning from failures</a> by Andrew Cropper and Rolf Morel.
<br><br>
Note that Popper is still in a beta phase. To cite the GitHub page:
<i><b>
<pre>
Popper is still a major work-in-progress. Be prepared for bugs, demons, and backwards-breaking changes!
</pre>
</b></i>

<h2>My Popper encodings</h2>
Many of these encoding are ports from Metagol, Progol, the old Popper version, etc. Note that some of them might not be of general interest.
<br>
Most programs are run like this:
<pre>
$ popper3 popper.py --debug --eval-timeout 0.01 --timeout 999999 problem_directory
</pre>
The links below are to a directory which contains three files (all are needed to run Popper):
<ul>
  <li> <code>exs.pl</code>: File including the positive and negative examples of the predicate.
  <li> <code>bk.pl</code>: File including the background knowledge (BK), i.e. the Prolog predicates that can be used.
  <li> <code>bias.pl</code>: Includes the bias, such as
  <ul>
    <li> maximum number of variables, body predicates, and clauses. This file includes some info about the problem. </li>
    <li> if predicate invention should be used (<code>enable_pi</code>) </li>
    <li> which predicates to use in the head and body </li>
    <li> type of the arguments of the predicates (not needed but might boost performance) </li>
    <li> direction (in/out) of the predicates (not needed but might boost performance) </li>
  </ul>
</ul>

<ul>
  <li> <a href="addlast">addlast</a></li>
  Program found in 0.2s:
<pre>
f(A,B) :- last(A,C),cons(C,A,B).
</pre>
  <li> <a href="adjacent_to_red">adjacent_to_red</a></li>
  Program found in 0.25s:
<pre>
target(A) :- edge(A,B),colour(B,C),red(C).
</pre>
  
<li> <a href="append">append</a></li>
    Program found in 18s:
<pre>
target(A,B,C):- eq(B,C),empty(A).
target(A,B,C):- tail(C,D),target(D,B,A). 
</pre>
  
  <li> <a href="arch">arch</a></li>
 Program found in 0.2s:
<pre>
arch(A,B,C) :- supports(B,A),not_touches(B,C).
</pre>
  
  <li> <a href="book2">book2</a></li>
   Program found in 0.2s:
<pre>
book(A,B,C,D) :- editor(A,D),author(A,B),title(A,C).
</pre>
  
  <li> <a href="book3">book3</a></li>
   Program found in 0.3s:
<pre>
book(A,B):- list3(B,E,D,C),editor(A,C),title(A,D),author(A,E).
</pre>
  

  <li> <a href="clpfd_test">clpfd_test</a> Testing SWI-Prolog's <code>clpfd</code> package to find constraints given some examples. This program use my SWI Prolog utils module <a href="/swi_prolog/hakank_utils.pl">hakank_utils.pl</a></li>
   Program found in 0.7s:
<pre>
target(A,B,C):- exactly(A,B,C).
</pre>
  
  <li> <a href="constants1_b">constants1_b</a> using "named constants"</li>
   Program found in 0.2s:
<pre>
p(A,B) :- const(B),const1(A).
p(A,B) :- const2(A),const2(B).
p(A,B) :- const(B),const4(A).
</pre>
  
  <li> <a href="cyclic">cyclic</a></li>
   Program found in 0.9s:
<pre>
cyclic(A) :- arc(A,B,C),path(A,C,B).
</pre>
  
  <li> <a href="cyclic-pi">cyclic-pi</a> (Testing `enable_pi` but another non-PI solution is found.) </li>
   Program found in 0.5s:
<pre>
cyclic(A) :- arc(A,B,C),arc(A,C,B).
cyclic(A) :- arc(A,B,C),arc(A,D,B),arc(A,C,D).
</pre>
  
  <li> <a href="droplast">droplast</a></li>
   Program found in 1.3s:
<pre>
f(A,B) :- tail(A,B).
f(A,B) :- head(A,D),tail(A,E),f(E,C),cons(D,C,B).
</pre>
  
  <li> <a href="even">even</a></li>
   Program found in 0.2s:
<pre>
f(A) :- zero(A).
f(A) :- succ(B,A),succ(C,B),f(C).
</pre>
  
  <li> <a href="evs">evs</a></li>
   Program found in 2.8s:
<pre>
evs(A) :- empty(A).
evs(A) :- head(A,B),even(B),tail(A,D),tail(D,E),head(D,C),odd(C),evs(E).
</pre>
  
  <li> <a href="facebook_puzzle">facebook_puzzle</a><br>
  Solving this puzzle:
  <pre>
  1 + 4 = 5
  2 + 5 = 12
  3 + 6 = 21
  5 + 8 = ??
</pre>
  </li>
   Program found in 1.7s:
<pre>
f(A,B,C):- mult(A,B,D),plus(A,D,C).
</pre>
  
  <li> <a href="find_duplicates">find_duplicates</a></li>
   Program found in 1.3s:
<pre>
f(A,B) :- tail(A,C),head(A,B),element(C,B).
f(A,B) :- tail(A,C),f(C,B).
</pre>
  
  
  <li> <a href="find_last">find_last</a></li>
   Program found in 0.2s:
<pre>
find_last(A,B) :- my_head(A,B),my_tail(A,C),empty(C).
find_last(A,B) :- my_tail(A,C),find_last(C,B).
</pre>

  <li> <a href="float_test">float_test</a> Just a simple test of using floats</li>
   Program found in 0.2s:
<pre>
target(A,B,C):- times(A,B,C).
</pre>

  
  <li> <a href="grammar1">grammar1</a></li>  
   Program found in 13.0s:
<pre>
s(A,B) :- np(D,B),np(A,C),vp(C,D).
</pre>

  
  <li> <a href="graph_coloring">graph_coloring</a></li>
   Program found in 0.25s:
<pre>
target(A) :- edge(A,B),colour(B,C),colour(A,C)
</pre>

  
  <li> <a href="graph_connectedness">graph_connectedness</a></li>
   Program found in 0.2s:
<pre>
target(A) :- edge(A,B),colour(A,C),colour(B,C).
</pre>

  
  <li> <a href="graph_reachability">graph_reachability</a></li>
   Program found in 0.2s:
<pre>
p(A,B) :- edge(A,B).
p(A,B) :- edge(A,C),p(C,B).
</pre>
  
<li> <a href="last">last</a></li>
   Program found in 7.8s:
<pre>
last(A,B) :- head(B,A),not_empty(B).
last(A,B) :- tail(B,C),last(A,C).
</pre>

<li> <a href="leap_year">leap_year</a></li>
   Program found in 1.5s:
<pre>
leapyear(A) :- divisible(A,B),known_divider400(B).
leapyear(A) :- divisible(A,C),known_divider4(C),not_divisible(A,B),known_divider100(B).
</pre>

  <li> <a href="length">length</a></li>
   Program found in 1.1s:
<pre>
f(A,B) :- empty(A),zero(B).
f(A,B) :- tail(A,D),f(D,C),succ(C,B).
</pre>
  
  <li> <a href="less_than">less_than</a></li>
   Program found in 1.3s:
<pre>
target(A,B) :- succ(A,B).
target(A,B) :- succ(A,C),target(C,B).
</pre>

  
<li> <a href="member">member</a></li>
   Program found in 0.5s:
<pre>
mem(A,B) :- head(B,A).
mem(A,B) :- tail(B,C),mem(A,C).
</pre>

<li> <a href="mutual_recursion">mutual_recursion</a></li>
   Program found in 1.6s:
<pre>
even(A):- zero(A).
even(A):- s(A,B),s(B,C),even(C).
</pre>

  
<li> <a href="nextto">nextto</a></li>
   Program found in 0.3s:
<pre>
nextto(A,B,C):- tail(C,D),head(C,A),head(D,B).
nextto(A,B,C):- tail(C,D),nextto(A,B,D).
</pre>


<li> <a href="nextto2">nextto2</a></li>
   Program found in 0.3s:
<pre>
nexttox(A,B,C):- diff1(D,E),nth1x(D,C,A),nth1x(E,C,B).
</pre>

Alternative variant (using <code>diff/3</code> instead of <code>code1</code>):<br>
   Program found in 0.9s:
<pre>
nexttox(A,B,C):- const1(D),diff(D,E,F),nth1x(F,C,A),nth1x(E,C,B).
</pre>


<li> <a href="nim">nim</a></li>
   Program found in 0.3s:
<pre>
won(A,B,C) :- move(B,C),divisible(C,D),num4(D),side(A).
</pre>

  <li> <a href="predecessor">predecessor</a></li>
   Program found in 0.2s:
<pre>
target(A,B) :- succ(A,B).
</pre>
  
  <li> <a href="primorial">primorial</a> (Kind of OK) </li>
   Program found in 0.7s:
<pre>
primorial(A):- const2(A).
primorial(A):- div3(A),div2(A).
</pre>
  
  <li> <a href="relatedness">relatedness</a> Note: <code>inv1</a> is an invented predicate</li>
   Program found in 4.0s:
<pre>
target(A,B) :- inv1(B,C),inv1(A,C).
inv1(A,B) :- parent(A,B).
inv1(A,B) :- parent(C,A),inv1(C,B).
</pre>
  
  <li> <a href="son">son</a></li>
   Program found in 0.2s:
<pre>
target(A,B) :- father(B,C),brother(A,C).
</pre>
  
<li> <a href="strings1">strings1</a></li>
   Program found in 43.9s:
<pre>
f(A,B):- copy1(B,A).
f(A,B):- copy1(A,C),f(B,C).
f(A,B):- skip1(A,C),f(B,C).
</pre>

<li> <a href="sum">sum</a></li>
   Program found in 0.3s:
<pre>
f(A,B) :- empty(A),zero(B).
f(A,B) :- cons(D,C,A),f(C,E),sum(D,E,B).
</pre>

  <li> <a href="trains">trains</a></li>
   Program found in 0.3s:
<pre>
e(A) :- has_car(A,B),closed(B),short(B).
</pre>

  
  <li> <a href="undirected_edge">undirected_edge</a></li>
   Program found in 0.2s:
<pre>
target(A,B) :- edge(B,A).
target(A,B) :- edge(A,B).
</pre>
</ul>

<br>
<hr>
<address>
Back to my <a href="/">homepage</a><br>
Created by Hakan Kjellerstrand (<a href="mailto:hakank@gmail.com">hakank@gmail.com</a>)
</address>
</body> </html>
