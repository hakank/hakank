// 
// Project Euler problem 14 in SETL
//
// Problem 14
//
// """
// The following iterative sequence is defined for the set of positive integers:
//
// n n/2 (n is even)
// n 3n + 1 (n is odd)
//
// Using the rule above and starting with 13, we generate the following 
// sequence:
// 13 40 20 10 5 16 8 4 2 1
//
// It can be seen that this sequence (starting at 13 and finishing at 1) 
// contains 
// 10 terms. Although it has not been proved yet (Collatz Problem), it is 
// thought that all starting numbers finish at 1.
//
// Which starting number, under one million, produces the longest chain?
//
// NOTE: Once the chain starts the terms are allowed to go above one million.")
// """
//
// This SETL program was created by Hakan Kjellerstrand (hakank@bonetmail.com)
// Also see my SETL page: http://www.hakank.org/setl/
//

problem14 := procedure() {
  print("Problem 14 (with call to collatz1(): ");
  lens := {};
  max_len := 0;
  max_n := 1;

  n := 1;
  while (n < 1000000) {
    m := n;
    c_len := 1;
    while (m > 1) {
      mc := lens[m];
      if (mc != om) {
        // use the cached result
        c_len += mc - 1;
        m := 1;
      } else {
        // else calculate the value
        m := collatz1(m);
        
        c_len += 1;
      }
    }
    lens[n] := c_len; // put in cache
    
    // we got a new max value
    if (c_len > max_len) {
      max_len := c_len;
      max_n := n;
      print("n:",n, " len:", c_len);
    }
    n += 1;
  }
  
  print("max_n:", max_n, " max_len:", max_len);
  
};

problem14b := procedure() {
  print("Problem 14b (without call to collatz1(): ");
  lens := {};
  max_len := 0;
  max_n := 1;

  n := 1;
  while (n < 1000000) {
    m := n;
    c_len := 1;
    while (m > 1) {
      mc := lens[m];
      if (mc != om) {
        c_len += mc - 1;
        m := 1;
      } else {
        // else calculate the value
        // m := collatz1(m);
        // Without the call to collatz1(m) it's
        // a little bit faster
        if (m % 2 == 0) {
          m /= 2;
        } else {
          m := 3*m + 1;
        }
        
        c_len += 1;

      }
    }

    lens[n] := c_len; // put in cache
    
    // we got a new max value
    if (c_len > max_len) {
      max_len := c_len;
      max_n := n;
      print("n:",n, " len:", c_len);
    }

    n += 1;

  }
  
  print("max_n:", max_n, " max_len:", max_len);
  
};

collatz1 := procedure(n) {
  if (n % 2 == 0) {
    return n \ 2;
  } else {
    return 3*n + 1;
  }
};


// Using built-in cache (~8s)
collatzLen := cachedProcedure (n) {
  if (n <= 1) { return 1; }
  if (n % 2 == 0) {
    return collatzLen(n \ 2) + 1;
  } else {
    return collatzLen(3*n + 1) + 1;
  }
};

// faster: about 7.8s
problem14c := procedure() {
  longestSeq := 1;
  startingNum := 1;
  for (j in [2..1000000-1]) {
    c := collatzLen(j);
    if (c > longestSeq) {
      longestSeq := c;
      startingNum := j;
      // print("\tj:$j$ longestSeq: $longestSeq$ startingNum:$startingNum$");
    }
  }

  print("longestSeq: $longestSeq$ startingNum:$startingNum$");

};

// shorter but slightly slower: 8.7s
problem14d := procedure() {
  c := [ collatzLen(n) : n in [1..1000000-1]];
  p := max(c);
  print("p: $p$ num: $first([i : i in [1..#c] | c[i] == p])$");

};

// problem14();
// problem14b();
problem14c();
// problem14d();

