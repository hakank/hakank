{- 
  
  Euler #12 in Curry

  Problem 12
  """
  The sequence of triangle numbers is generated by adding the natural numbers. 
  So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
  The first ten terms would be:

  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

  Let us list the factors of the first seven triangle numbers:

       1: 1
       3: 1,3
       6: 1,2,3,6
      10: 1,2,5,10
      15: 1,3,5,15
      21: 1,3,7,21
      28: 1,2,4,7,14,28

  We can see that the 7th triangle number, 28, is the first triangle number 
  to have over five divisors.

  Which is the first triangle number to have over five-hundred divisors?")
  """

  The Haskell version of euler12b takes about 0.5s.


  This program was created by Hakan Kjellerstrand (hakank@gmail.com)
  Also see my Curry page: http://hakank.org/curry/
  
  
-}

import Data.List
-- import Control.AllValues
-- import Control.SetFunctions
import HakankUtils (numDivisors)
-- import CLP.FD


-- This seems to be faster than primeFactors
-- allFactors' _ 1 _ = []
-- allFactors' n m d | m > 1 = -- if d > 1+(n `div` 2) then
--                           if d > n then
--                             [m]
--                           else if m `mod` d == 0 then
--                             d : allFactors' n (m `div` d) d
--                           else
--                             allFactors' n m (d+1)
-- allFactors n = allFactors' n n 2


-- Count the number of occurrences of elements in list (x:xs)
-- collect xs =  map (\i sum (==i) xs ) nub xs


-- divisors1 n = 1 : [i | i <- [2..1+(n `div` 2)], n `mod` i == 0 ] ++ [n]

-- Brute force. Quite elegant but way too slow, especially since divisors is so slow...
-- But it's way too slow and is not complete.
-- euler12a = takeWhile (\n -> length (divisors1 n) <= 500) $ scanl1 (+) [1..]


-- slow: 23min59.3s
-- (The Haskell version of this takes about 0.5s!)
euler12b :: Int
euler12b = last t2 - (foldr1 (-) t2) + 1
           where
             t = takeWhile (\n -> numDivisors n <= 500) $ scanl1 (+) [1..]
             len = length t
             t2 = drop (len-2) t

--
-- Simpler (and much faster especially for KiCS2) than euler12b.
--
euler12c :: Int
euler12c = head $ dropWhile (\n -> numDivisors n <= 500) $ scanl1 (+) [1..]


main :: IO ()
main = do
         -- print euler12a -- Way too slow and not correct!

         -- PAKCS:  Execution time: 1439275 msec. / elapsed: 1642612 msec. 
         -- KICS2: Out of Memory: GHC compilation time: 1.32s / elapsed: 0:01.78 Execution time: 339.33s / elapsed: 5:46.41
         -- Curry2Go: Compilation time: 2.00s / elapsed: 0:01.53 Execution time: 1145.15s / elapsed: 7:21.41 runtime: out of memory!!! 
         -- print euler12b

         -- PAKCS: Execution time: 1308670 msec. / elapsed: 1493813 msec.
         -- KICS2: KiCS2 compilation time: 1.75s / elapsed: 0:02.13 GHC compilation time: 1.25s / elapsed: 0:01.72 Execution time: 13.09s / elapsed: 0:13.17
         -- Curry2Go: > 120min
         print euler12c