/* 

  Symbolic function induction in Picat.

  From https://www.doc.ic.ac.uk/~mpd37/teaching/2014/ml_tutorials/2014-10-15-wood-anglican.pdf
  Page 34ff
  """
  Symbolic Function Induction
  What’s the next value? And the function?

  Input    Output
  ---------------
  1        5
  2        3
  3        1
  4        ?
  """

  This program solves a integer sequence puzzles with symbolic solutions like the
  one above. Some other examples, which are all solved by this program (see the
  examples in the data section below):

  * What number should replaced the question mark?
    1 + 4 = 5
    2 + 5 = 12
    3 + 6 = 21
    5 + 8 =  ?

  * What number should replaced the question mark?
    9 = 90
    8 = 72
    7 = 56
    6 = 42
    3 = ?

  *  What number should replaced the question mark?
        3         9       8
       44        32      75
     8   4      7  2    7  ? 

  * Fibonacci sequence: 1,1,2,3,5,8,13,21,?

  * 1,2,6,42,1806, ?

  * What number should replaced the question mark?
    11x11 = 4
    22x22 = 16
    33x33 = ?


  The power - and the drawback - of the program is that it brute forces 
  (enumerates) all possible solution using Picat's non-determinism (backtracking
  with fail/0). 

  The program supports the following infix operators:
  - +, -, *, /, //, **, ...
  - mod, div, /\, \/. ,,
  It also supports non-infix functions, including user-defined functions 
  of arity 1, 2, and 3. See the definition of aval/2 below. 


  Previously I have used JGAP and/or Popper for solving sequence puzzles
  to get alternative solutions (mpst often after solving the puzzle by hand):

   - Symbolic Regression (JGAP): http://hakank.org/jgap
     It randomly finds solutions using Genetic Programming, 
     some solutions are quite unexpecting.

   - Inductive programming (Popper): http://hakank.org/popper/
     Popper, on the other hand, just find one solution (the minimal number
     of literats in the program), but it can solve much more complex problems 
     than these kind of sequence puzzles, and it supports both recursive 
     function as well as predicate invention. 
     However, currently Popper struggles to find proper constants and one 
     have to use "named constants" for this. 

  Compared to these two programs, this Picat program is a little easier to 
  use since it automatically generates alternative solutions. Though it
  might take a while due to combinatorial explosion.

  The main usage for this program is solving "plain" integer sequence puzzles,
  but I couldn't help trying to implements some other stuff.

  Some features
  - debug
    Using get_global_map().put("debug",true)

    This will show some more information about the progress, including
    error messages thrown by catch/3.

  - support of floats using some approximate calculation.

    This is done using 
        get_global_map().put("use_approx",MaxError)
    where MaxError is the maximum allowed error.

    See 
      * planets
      * planets_b
      * circle
      * distance

    Note that the program only supports discrete constants which must
    be defined in the Constants variables. However, one can use 
    a list of float values as constants which might help a little.

  - support of non-infix functions, e.g. user defined functions (e.g. f/2 )

    * User-defined functions
      There is an EXPERIMENTAL approach for user defined functions of
      arity 1, 2, and 3.

      See some simple examples:
        - prime_test.
        - planets

      In the Opts map the function must be added in the appropriate place:

      - arity 1 (as well as built-in arity 1 function)
         op1=["prime","sqrt"]
      - arity 2
         user=["distance"]
      - arity 3
         user3=["if_then_else"]
      
      - arity2 built-in infix operators are placed in
        infix=["+","-","*","mod"]

      Note that the functions must be defined as
         eval('f'(X,Y)) => ...
      last in this program.

  - show only the first solution for a specific value of the
    unknown.
    For example when checking the different solutions 
    of a puzzle (especially when using the expanded variant).

    This is done by setting
        get_global_map().put("only_first_solution",true)
  
    Example: 
     * infamous_equation

  TODO:
  - a flag that all numbers must be used exactly once, such
    as for number_puzzle_4 and number_puzzle_4b.

  - some intelligence, such as symmetry breaking rules that 
      (a + b) == (b + a)

  - perhaps: support for recursion of the found function. 
    This will probably require a major rewrite of the program.


  Aside from the examples in this program, there are some
  more examples including tests of the user-defined functions,
  more tests with floats etc. 
  See  at http://hakank.org/picat/ 
  

  This program was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

import util,os.

main => go.


%
% There are also some problems defined in a separate file.
% See http://hakank.org/picat/ for examples, search for
% "symbolic_function_induction_*.pi)
%
% Run as
%  $ picat symbolic_function_induction.pi symbolic_function_induction_datafile.pi
%
main(ARGS) =>
  File = ARGS[1],
  println(file=File),
  if file_exists(File) then
    cl(File),
    data(Experiment,Data,Vars,Unknown,Ops,Constants,MaxC),
    println(experiment=Experiment),
    println(data=Data),
    println(vars=Vars),
    println(unknown=Unknown),
    println(ops=Ops),
    println(constants=Constants),
    println(maxC=MaxC),

    Map = get_table_map(),  
    member(MaxCount,1..MaxC),
    println(maxCount=MaxCount),
    induce(Data,Unknown,Ops,Constants,Vars.map(to_uppercase),MaxCount,Map),
    fail,
    nl
    
  else
    printf("File %w does not exist!",File),
    nl
  end.


%
% Test some predefined examples.
%
go ?=>
  % data(simple,Data,Vars,Unknown,Ops,Constants,MaxC), % 7-2x
  
  % data(number_puzzle_1,Data,Vars,Unknown,Ops,Constants,MaxC),
  
  data(facebook_puzzle,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(facebook_puzzle_b,Data,Vars,Unknown,Ops,Constants,MaxC),
  
  % data(facebook_puzzle2,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(facebook_puzzle2_b,Data,Vars,Unknown,Ops,Constants,MaxC),

  % data(pickover_puzzle1,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(fibonacci,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(infamous_equation,Data,Vars,Unknown,Ops,Constants,MaxC),

  % data(sequence_1,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(sequence_2,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(sequence_3,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(sequence_4,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(sequence_6,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(sequence_7,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(sequence_8,Data,Vars,Unknown,Ops,Constants,MaxC),
  
  % data(triangular,Data,Vars,Unknown,Ops,Constants,MaxC),

  % data(equation2,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(equation2b,Data,Vars,Unknown,Ops,Constants,MaxC), % expanded version
  
  % data(equation3,Data,Vars,Unknown,Ops,Constants,MaxC),
  % data(equation3b,Data,Vars,Unknown,Ops,Constants,MaxC), % variant of equation3
  
  % data(puzzle3,Data,Vars,Unknown,Ops,Constants,MaxC),  


  % EXPERIMENTAL: Using float variables
  % For this to work, set
  %     get_global_map().put(use_approx,MaxError)
  % data(planets,Data,Vars,Unknown,Ops,Constants,MaxC), 
  % data(planets_b,Data,Vars,Unknown,Ops,Constants,MaxC),  % just use_approx


  Map = get_table_map(),  
  member(MaxCount,1..MaxC),
  println(maxCount=MaxCount),
  induce(Data,Unknown,Ops,Constants,Vars.map(to_uppercase),MaxCount,Map),
  fail,
  nl.

go =>
  % println(map_after=get_table_map()),
  nl.

/*
  Main checker of the induced function (program) Code
*/
induce(Data,Unknown,Ops,Constants,Vars,MaxCount,Map) =>
  Count = 0,

  % Get the induced function
  Code = get_op(Count,MaxCount,Constants,Vars,Ops),
  % Skip if we already seen this as a correct solution.
  if Map.has_key(Code) then
    fail
  end,
  
  Approx = get_global_map().get("use_approx",false),
  All = [],
  foreach([Vals,Y] in Data)
    Y2 = check(Code, Vars,Vals,Map),
    if get_global_map().has_key("debug") then
      Diff = Y-Y2,
      printf("code:%w vals: %w y: %w y2: %w  diff: %w\n",Code,Vals,Y,Y2,Diff)
    end,
    if Approx != false then
      % Floats
      if abs(1.0*Y-1.0*Y2) <= Approx then
        All := All ++ [[Vals,Y]]
       else
         fail
       end
    else
      % Integer / Exact solution
      if 1.0*Y == 1.0*Y2 then
        All := All ++ [[Vals,Y]]
      else
        fail
      end
    end
  end,
  % We have found a valid program 
  if All.length == Data.length then
    % Check the unknown
    Check = check(Code,Vars,Unknown,Map),
    % Only print unique solutions of the unknown?
    if get_global_map().has_key("only_first_solution"), Map.has_key(Check) then
      fail
    end,
    Map.put(Check,1),
    println(code=Code=All=[Unknown=Check]),

    %% This is for number_puzzle_4b to
    %% make it simpler to identify the proper solutions,
    %% i.e. that all numbers are used exactly once.
    % , NumUsed = [C : C in Code, digit(C)].remove_dups,
    % if NumUsed.len == Data[1,1].length then 
    %   println(numUsed=NumUsed=len=NumUsed.len)
    % end
  % else
  %   println(nope)
  end,
  Map.put(Code,1), % do not show this solution again
  flush(stdout).

%
% Check the code replacing Vars -> Vals (as string)
%
check(Code,Vars,Vals,Map) = Res =>
  Code2 = Code,
  foreach({Var,Val} in zip(Vars,Vals))
    Code2 := replace_string(Code2,Var,Val.to_string)
  end,
  % catch division by 0 etc
  if get_global_map().has_key("debug") then
    catch(Res = parse_term(Code2).eval,Error,(printf("Error in code %w: %w\n",Code2,Error),flush(stdout),fail))    
  else
    catch(Res = parse_term(Code2).eval,_Error,fail)    
  end.


%
% Generation of constants, variables, or functions by enumeration
% (member/2). 
%

%
% Generate a constant or a variable
%
get_constant(Constants,Vars) = Constant.to_string =>
  (member(Constant,Vars) ; member(Constant,Constants)).  


%
% Generate a (sub) function/program
%
get_val(Count,MaxCount,Constants,Vars,Ops) = V1 =>
  Count <= MaxCount,
   (
     V1 = get_constant(Constants,Vars)  % a constant: a value or a variable
    ; 
     V1 = get_op1(Count+1,MaxCount,Constants,Vars,Ops) % arity 1
    ;
     V1 = get_op(Count+1,MaxCount,Constants,Vars,Ops) % built-in infix
    ; 
     V1 = get_user_op2(Count+1,MaxCount,Constants,Vars,Ops) % non infix, user defined arity 2
    ; 
     V1 = get_user_op3(Count+1,MaxCount,Constants,Vars,Ops) % non infix, user defined arity 3
    ).
    

%
% User defined/built-in function of arity 1
%
get_op1(Count,MaxCount,Constants,Vars,Ops) = Res.to_string =>
  Count <= MaxCount,
  member(Op,Ops.get(op1,[])),
  V1 = get_val(Count,MaxCount,Constants,Vars,Ops),
  Res = "" ++ Op ++ "(" ++ V1 ++ ")".

%
% User defined non-infix of arity 2
% E.g. prime, gcd
%
get_user_op2(Count,MaxCount,Constants,Vars,Ops) = Res.to_string =>
  Count <= MaxCount,
  member(Op,Ops.get(user,[])),
  V1 = get_constant(Constants,Vars),
  V2 = get_val(Count,MaxCount,Constants,Vars,Ops),
  (
    Res = "" ++ Op ++ "(" ++ V1 ++ "," ++  V2 ++ ")"
  ;
    Res = "" ++ Op ++ "(" ++ V2 ++ "," ++  V1 ++ ")"
  ).

%
% User defined of arity 3
% E.g. if_then_else
% 
get_user_op3(Count,MaxCount,Constants,Vars,Ops) = Res.to_string =>
  Count <= MaxCount,
  member(Op,Ops.get(user3,[])),
  V1 = get_constant(Constants,Vars),
  V2 = get_val(Count,MaxCount,Constants,Vars,Ops),
  V3 = get_val(Count,MaxCount,Constants,Vars,Ops),  
  Res = "" ++ Op ++ "(" ++ V1 ++ "," ++  V2 ++ "," ++ V3 ++ ")".

%
% This is the "main" function generator, calling
% each variant using enumeration.
%
table
get_op(Count,MaxCount,Constants,Vars,Ops) = Res =>
  Count <= MaxCount,
  (
   Res = get_val(Count,MaxCount,Constants,Vars,Ops)
   ;
   (
    V1 = get_constant(Constants,Vars),
    % V1 = get_val(Count,MaxCount,Constants,Vars,Ops),  
    member(Op,Ops.get(infix,[])),
    V2 = get_val(Count+1,MaxCount,Constants,Vars,Ops),
    (
      Res = "(" ++ V1 ++ " " ++ Op ++ " " ++ V2 ++ ")"
     ; 
      Res = "(" ++ V2 ++ " " ++ Op ++ " " ++ V1 ++ ")"
    )
  )
 ).


%
% Utilities
%

/*
  Create data for a sequence
  Input:
  - Seq: a list of input (integers)
  - N: size of each slot
  Output:
  - Data: The data matrix
  - Unknown: The unknown (the last data entry)
  - Vars: "a","b", .... (of size N)
  
  Example (see data(fibonacci,..))
  *  make_seq([1,1,2,3,5,8,13,21],2,Data,Unknown,Vars),
     Generates: 
     data = [[[1,1],2],[[1,2],3],[[2,3],5],[[3,5],8],[[5,8],13],[[8,13],21]]
     Unknown = [8,13]
     Vars: ["a","b"]

  *  make_seq([1,1,2,3,5,8,13,21],3,Data,Unknown,Vars),
    generates the following
    Data:[[[1,1,2],3],[[1,2,3],5],[[2,3,5],8],[[3,5,8],13],[[5,8,13],21]]
     Unknown: [5,8,13]
     Vars: ["a","b","c"]
*/  
make_seq(Seq,N,Data,Unknown,Vars) =>
  Len = Seq.len,
  Data1 = [],
  foreach(I in 1..Len-N)
    T = [ [Seq[I..I+N-1],Seq[I+N]] ],
    Data1 := Data1 ++ T
  end,
  Unknown = Seq[Len-N+1..Len],
  alpha(Alpha),
  Vars = [C.to_string : C in Alpha[1..N]],
  Data = Data1.  

% It's recommended to use uppercase variables
% (it's also enforced in the call to induce in go/0.)
alpha("ABCDEFGHIJKLMNOPQRSTUVWXYZ").

/*

  Given a sequence (Seq), this returns a "pointwise" dataset,
  data of the form
    [
      [[1],Seq[1]],
      [[2],Seq[2]],
      [[3],Seq[3]],
      ..
   ]
  The assumption is that the list starts with 1.

  Unknown is Seq.len + 1
  Vars is simply ["A"].

  Example:
   make_point_seq([1,8,27,64,125,217],Data,Unknown,Vars),
  Generates:
   Data: [[[1],1],[[2],8],[[3],27],[[4],64],[[5],125],[[6],216]]
   Unknown: [7]
   Vars = ["A"]

*/
make_point_seq(Seq,Data,Unknown,Vars) =>
  Data1 = [],
  Len = Seq.len,
  foreach(I in 1..Len)
    Data1 := Data1 ++ [[[I],Seq[I]]]
  end,
  Data = Data1,  
  Unknown = [Len+1],
  Vars = ["A"].


/*

  Generalized version of replacing a _string_ with a character or string
  (which is not possible with Picat's replace/3).
  Example:
    Picat> S=replace_string("xabc_nd_abc","abc","xyz")           
    S = [x,x,y,z,'_',n,d,'_',x,y,z]  
*/
replace_string(String,From,To) = Result.flatten =>
    replace_string(Result,From,To,String,[]).

replace_string([To|Cs],From,To) --> some(From), replace_string(Cs,From,To), !. % First string
replace_string([C,To|Cs],From,To) --> [C], some(From), replace_string(Cs,From,To), !.
replace_string([C|Cs],From,To)    --> [C], replace_string(Cs,From,To).
replace_string([],_From,_To)      --> [].

% Maches anything (as much as possible) with capture.
any([C|Rest]) --> [C], any(Rest).
any([])  --> [].

% Accept at least one character, with capture
some(Cs) --> any(Cs), {Cs.len > 0}.


%
% Data
%

/*
  This is the problem that started/inspired this program.

  From https://www.doc.ic.ac.uk/~mpd37/teaching/2014/ml_tutorials/2014-10-15-wood-anglican.pdf
  Page 34ff
  """
  Symbolic Function Induction
  What’s the next value? And the function?

  Input    Output
  ---------------
  1        5
  2        3
  3        1
  4        ?
  """

  Solutions:
  maxCount = 3
  code = ((7 - A) - A) = [[[1],5],[[2],3],[[3],1]] = [[4] = -1]
  code = (7 - (A + A)) = [[[1],5],[[2],3],[[3],1]] = [[4] = -1]
  code = (7 - (A * 2)) = [[[1],5],[[2],3],[[3],1]] = [[4] = -1]
  code = (7 - (2 * A)) = [[[1],5],[[2],3],[[3],1]] = [[4] = -1]

  I.e. 7 - 2*A

*/
data(simple,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  % Data = [[[1],5],
  %         [[2],3],
  %         [[3],1]
  %         ],
  % Vars = ["X"],
  % Unknown = [4],
  
  % Shorter:
  make_point_seq([5,3,1],Data,Unknown,Vars),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  MaxC = 3.


/*
  Originally from Roger Alsing/Johans's blog post
  "Genetic Programming: Code smarter than you"
  https://rogerjohansson.blog/2010/02/14/genetic-programming-code-smarter-than-you/

  Given the data table below, what is
     9 7 ?
  2 3 10
  7 2 63
  6 5 66
  8 4 96
  9 7 ?
  
  Solutions:
  maxCount = 3
  code = (X * (X + Y)) = [[[2,3],10],[[7,2],63],[[6,5],66],[[8,4],96]] = [[9,7] = 144]

  Cf:
  - http://hakank.org/jgap/number_puzzle1.conf
  - http://hakank.org/popper/number_puzzle1/

*/
data(number_puzzle_1,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [[[2,3],10],
          [[7,2],63],
          [[6,5],66],
          [[8,4],96]
          ],
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  Vars = ["X","Y"],
  MaxC = 3,  
  Unknown = [9,7].
  

/*

  http://hakank.org/jgap/facebook_puzzle.conf

  https://www.facebook.com/Lustify/posts/1319105168505523?comment_id=1197501380680610&reply_comment_id=130654025754830&notif_id=1620035705731117&notif_t=comment_mention&ref=notif
   1 + 4 = 5
   2 + 5 = 12
   3 + 6 = 21
   5 + 8 = ??

  Solutions:
  maxCount = 3
  code = (X + (X * Y)) = [[[1,4],5],[[2,5],12],[[3,6],21]] = [[5,8] = 45]
  code = (X * (X + 4)) = [[[1,4],5],[[2,5],12],[[3,6],21]] = [[5,8] = 45]
  code = (X * (Y + 1)) = [[[1,4],5],[[2,5],12],[[3,6],21]] = [[5,8] = 45]

  Here we only get one solution: 45. 
  See facebook_puzzle_b for another solutions.

*/
data(facebook_puzzle,Data,Vars,Unknown,Ops,Constants,MaxC) :-  
  Data = [[[1,4],5],
          [[2,5],12],
          [[3,6],21]
          ],
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  Vars = ["X","Y"],
  MaxC = 3,  
  Unknown = [5,8].


/*
  Same as facebook_puzzle but using a different representation
  which generates a lot of different solutions.

  http://hakank.org/jgap/facebook_puzzle_b.conf
  https://www.facebook.com/Lustify/posts/1319105168505523
   1 + 4 = 5
   2 + 5 = 12
   3 + 6 = 21
   5 + 8 = ??
  Here we "expand" the representation:
  --> 
  0 0 0  1 4 5
  1 4 5  2 5 12
  2 5 12 3 6 21
  3 6 21 5 8 ?

  Solutions: 
  maxCount = 3
  code = (C + (D + E)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 25]
  code = (D + (E + C)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 25]
  code = ((E * D) + D) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 45]
  code = (D * (A + 5)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 40]
  code = (D * (D + 4)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 45]
  code = ((1 + E) * D) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 45]
  ...
  MaxCount 5
  ...
  code = (A + (A + (C + 5))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 23]
  code = (A + (C + (D + 4))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 24]
  code = (A + (1 + (D * E))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 44]
  code = (D + (E + (A * E))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 37]
  code = (D * ((D + E) - A)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 50]
  code = (D * (5 + (C / E))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 32.5]
  code = (5 + (A * (A + 6))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 32]
  code = (5 + (A * (D + 5))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,12,5,8] = 35]


  Note that using this representation we get quite a few solutions:
    23
    24
    25
    32
    32.5
    35
    37
    40
    45  
    50

*/
data(facebook_puzzle_b,Data,Vars,Unknown,Ops,Constants,MaxC) :- 
  Data = [[[0,0, 0,1, 4],5],
          [[1,4, 5,2, 5],12],
          [[2,5,12,3, 6],21]
          ],
  % get_global_map().put("only_first_solution",true), % only unique solutions
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  Vars = ["A","B","C","D","E"],
  MaxC = 5,  
  Unknown = [3,6, 12,5, 8].


/* 

  http://hakank.org/jgap/facebook_puzzle2.conf
  https://www.facebook.com/Heavydsparks/photos/a.1432147377066939/2976473412634320/
   9 = 90
   8 = 72
   7 = 56
   6 = 42
   3 = ?

  Solutions:
  maxCount = 3
  code = (X + (X * X)) = [[[9],90],[[8],72],[[7],56],[[6],42]] = [[3] = 12]
  code = ((X * X) + X) = [[[9],90],[[8],72],[[7],56],[[6],42]] = [[3] = 12]
  code = (X * (X + 1)) = [[[9],90],[[8],72],[[7],56],[[6],42]] = [[3] = 12]
  code = ((X + 1) * X) = [[[9],90],[[8],72],[[7],56],[[6],42]] = [[3] = 12]
  code = (X * (1 + X)) = [[[9],90],[[8],72],[[7],56],[[6],42]] = [[3] = 12]
  code = ((1 + X) * X) = [[[9],90],[[8],72],[[7],56],[[6],42]] = [[3] = 12]

*/
data(facebook_puzzle2,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [[[9],90],
          [[8],72],
          [[7],56],
          [[6],42]
          ],
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  Vars = ["X"],
  MaxC = 3,  
  Unknown = [3].


/*
  Same as facebook_puzzle2 but with an "expanded" representation
  http://hakank.org/jgap/facebook_puzzle2_b.conf
  https://www.facebook.com/Heavydsparks/photos/a.1432147377066939/2976473412634320/
   9 = 90
   8 = 72
   7 = 56
   6 = 42
   3 = ?

  Note: There is an implicit "10 1" for the first equation
  10  1 9 90
   9 90 8 72
   8 72 7 56
   7 56 6 42
   6 42 3 ?

  Again, using an expanded representation, generates quite a few and different solutions:
  Solutions:
  maxCount = 1
  code = (X * Z) = [[[10,1,9],90],[[9,90,8],72],[[8,72,7],56],[[7,56,6],42]] = [[6,42,3] = 18]
  maxCount = 2
  maxCount = 3
  code = ((X * X) - X) = [[[10,1,9],90],[[9,90,8],72],[[8,72,7],56],[[7,56,6],42]] = [[6,42,3] = 30]
  code = (X * (Z + 0)) = [[[10,1,9],90],[[9,90,8],72],[[8,72,7],56],[[7,56,6],42]] = [[6,42,3] = 18]
  code = ((Z + 0) * X) = [[[10,1,9],90],[[9,90,8],72],[[8,72,7],56],[[7,56,6],42]] = [[6,42,3] = 18]
  code = (X * (Z * 1)) = [[[10,1,9],90],[[9,90,8],72],[[8,72,7],56],[[7,56,6],42]] = [[6,42,3] = 18]
  code = (Z + (Z * Z)) = [[[10,1,9],90],[[9,90,8],72],[[8,72,7],56],[[7,56,6],42]] = [[6,42,3] = 12]
  code = (Z * (X + 0)) = [[[10,1,9],90],[[9,90,8],72],[[8,72,7],56],[[7,56,6],42]] = [[6,42,3] = 18]
  code = (Z * (Z + 1)) = [[[10,1,9],90],[[9,90,8],72],[[8,72,7],56],[[7,56,6],42]] = [[6,42,3] = 12]


*/
data(facebook_puzzle2_b,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [[[10,1, 9],90],
          [[9,90, 8],72],
          [[8,72, 7],56],
          [[7,56, 6],42]
          ],
  % get_global_map().put("only_first_solution",true), % only unique solutions        
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  Vars = ["X","Y","Z"],
  MaxC = 3,  
  Unknown = [6,42,3].


/*
  
  http://hakank.org/jgap/pickover_puzzle1.conf
  https://twitter.com/pickover/status/1504602497280786435
  Pickover puzzle: https://twitter.com/pickover/status/1504602497280786435
  (https://gpuzzles.com/mind-teasers/very-easy-number-sequence-puzzle/ )
  
   What number should replaced the question mark?
      3         9       8
     44        32      75
   8    4    7   2    7  ? 
  
  Encoded as
     a
     b
   c  d 

  i.e. d is the output variable (unknown)

  Solutions:
  maxCount = 3
  code = ((A + 9) / A) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2.125]
  code = (B / (A + C)) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 5.0]
  code = (1 + (9 / A)) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2.125]
  code = (2 * (C - 6)) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2]
  code = (4 / (9 - C)) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2.0]
  code = (5 - (A / 3)) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2.333333333333333]
  ...
  code = (B + ((4 - C) * 10)) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 45]
  code = (C + (C - (2 + 10))) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2]
  code = ((1 + (B / 4)) - C) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 12.75]
  code = (C * (4 / (A + 5))) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2.153846153846154]
  code = (((B - 9) - A) / C) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 8.285714285714286]
  code = (C / ((A + 5) / 4)) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2.153846153846154]
  code = (((B - A) - 9) / C) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 8.285714285714286]
  code = (0 + (5 - (A / 3))) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2.333333333333333]
  code = (3 * (8 / (A + 3))) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 2.181818181818182]
  code = (((B - 5) - A) / 9) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 6.888888888888889]
  code = (3 + (3 / (6 - A))) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = 1.5]
  code = (6 / (7 - (B / 8))) = [[[3,44,8],4],[[9,32,7],2]] = [[8,75,7] = -2.526315789473684]

  The "intended" solution is (probably):
    (b / (a + c)) = 5

*/
data(pickover_puzzle1,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [[[3,44, 8],4],
          [[9,32, 7],2]
          ],
  % get_global_map().put("only_first_solution",true), % only unique solutions
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  Vars = ["A","B","C"],
  MaxC = 5,  
  Unknown = [8,75,7].


/*

  Fibonacci "expanded" version
  1,1,2,3
  1,2,3,5
  2,3,5,8
  3,5,8,13
  5,8,13,21
  8,13,21,34
  13,21,34,55
  21,34,55,89
  34,55,89,144
  55,89,144,233
  89,144,233,377

  Solutions:
  maxCount = 1
  code = (A + B) = [[[1,1],2],[[1,2],3],[[2,3],5],[[3,5],8],[[5,8],13],[[8,13],21]] = [[13,21] = 34]
  code = (B + A) = [[[1,1],2],[[1,2],3],[[2,3],5],[[3,5],8],[[5,8],13],[[8,13],21]] = [[13,21] = 34]

  n = 3
  data = [[[1,1,2],3],[[1,2,3],5],[[2,3,5],8],[[3,5,8],13],[[5,8,13],21]]
  maxCount = 1
  code = (B + C) = [[[1,1,2],3],[[1,2,3],5],[[2,3,5],8],[[3,5,8],13],[[5,8,13],21]] = [[8,13,21] = 34]
  code = (C + B) = [[[1,1,2],3],[[1,2,3],5],[[2,3,5],8],[[3,5,8],13],[[5,8,13],21]] = [[8,13,21] = 34]


  Note: Just for demonstration, here we generate N=2..3 (2 is sufficient)

*/
data(fibonacci,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  member(N,2..3),
  println(n=N),
  make_seq([1,1,2,3,5,8,13,21],N,Data,Unknown,Vars),
  println(data=Data),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  MaxC = 2.


/*

  The "infamous puzzle":
   11x11=4
   22x22=16
   33x33=?

  See
  http://hakank.org/jgap/equation.conf
  We represents this as
  1 1 1 1 4 
  2 2 2 2 16 
  3 3 3 3 ?

  Solutions:
  maxCount = 1
  code = (4 ** A) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 64]
  code = (4 ** B) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 64]
  code = (4 ** C) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 64]
  code = (4 ** D) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 64]
  maxCount = 2
  maxCount = 3
  code = (A * (A * 4)) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 36]
  code = (A * (B * 4)) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 36]
  code = ((1 + 3) ** A) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 64]
  code = ((2 + 2) ** A) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 64]
  code = ((2 * 2) ** A) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 64]
  code = ((2 ** 2) ** A) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 64]  
  code = (2 ** (2 ** A)) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 256]
  code = (4 * (A ** A)) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 108]
  code = (((4 / A) ** A) ** A) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 13.318294975359438]
  code = (B * (2 * (2 ** B))) = [[[1,1,1,1],4],[[2,2,2,2],16]] = [[3,3,3,3] = 48]


  Compare with my Picat (CP) approach in equation.pi which has the following solutions
  The constraint models above has 4 different models/interpretations and
  finds four different solutions of the puzzle:
    x1 = 36
    x2 = 18
    x3 = 64
    x4 = 108

  of which 18 is the only solution not found with this program.

  Also see: 
  MindYourDecision (Presh Talwalkar) has blogged/youtubed about it:
   "Viral Puzzle 11 x 11 = 4. The Correct Answer Explained" 
  - https://mindyourdecisions.com/blog/2016/09/21/viral-puzzle-11x11-4-the-correct-answer-explained/
  - https://www.youtube.com/watch?v=IQd1oDsHVSc

*/
data(infamous_equation,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [ [[1,1,1,1],4],
           [[2,2,2,2],16]
          ],
  Ops = new_map([infix=["+","-","*","/","**"]]),
  % Show only solutions with different values for the unknown
  % get_global_map().put("only_first_solution",true),
  Constants = 0..4,
  Vars = ["A","B","C","D"],
  MaxC = 6,  
  Unknown = [3,3,3,3].




/*
  See http://hakank.org/jgap/sequence_puzzle.conf
  From 
  "1/20-1/27 Quick Quiz Solution"
  http://testplease.com/?p=1539
  """
  What number comes next in the sequence?
  1, 8, 27, 64, 125, 216, ...
  ... 
  The answer is 343.
  
  The sequence was a series of cubed numbers.
  """
  Solution
  maxCount = 1
  code = (A ** 3) = [[[1],1],[[2],8],[[3],27],[[4],64],[[5],125],[[6],216]] = [[7] = 343]

*/
data(sequence_1,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  make_point_seq([1,8,27,64,125,216],Data,Unknown,Vars),
  println(data=Data),
  println(unknown=Unknown),
  println(vars=Vars),
  Ops = new_map([infix=["+","-","*","/","**"]]),
  Constants = 0..10,          
  MaxC = 2.


/*  
  See http://hakank.org/jgap/sequence_puzzle.conf
  From http://wiki.answers.com/Q/What_number_comes_next_in_the_sequence_1_2_6_42_1806
  
   1, 2, 6, 42, 1806, ?
  
  Solutions:
  maxCount = 3
  code = (A + (A * A)) = [[[1],2],[[2],6],[[6],42],[[42],1806]] = [[1806] = 3263442]
  code = (A * (A + 1)) = [[[1],2],[[2],6],[[6],42],[[42],1806]] = [[1806] = 3263442]

*/
data(sequence_2,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  % Note: Since we don't really know the type of sequence we
  % test both a "point sequence" and a "recursive sequence".
  % It's a "recursive" sequence (i.e. make_seq/5) 
  ( make_point_seq([1,2,6,42,1806],Data,Unknown,Vars)
    ; 
    make_seq([1,2,6,42,1806],1,Data,Unknown,Vars)
  ),
  println(data=Data),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,          
  MaxC = 3.


/*

  http://hakank.org/jgap/sequence_puzzle.conf
  1.60,
  2,30,
  3,20,
  4,15,
  5,12
  6, ?

  Solutions:
  maxCount = 1
  code = (60 / A) = [[[1],60],[[2],30],[[3],20],[[4],15],[[5],12]] = [[6] = 10.0]

*/
data(sequence_3,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  make_point_seq([60, 30, 20, 15, 12],Data,Unknown,Vars),
  println(data=Data),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10 ++ [60],
  MaxC = 3.


/* 
  From http://in.answers.yahoo.com/question/index?qid=20091119001407AAMWPf5
  1,2,
  2,12,
  3,90,
  4,104

  Solutions:
  maxCount = 5
  code = (A * (A + (A ** A))) = [[[1],2],[[2],12],[[3],90],[[4],1040]] = [[5] = 15650]
  code = ((A + (A ** A)) * A) = [[[1],2],[[2],12],[[3],90],[[4],1040]] = [[5] = 15650]
  code = (A * ((A ** A) + A)) = [[[1],2],[[2],12],[[3],90],[[4],1040]] = [[5] = 15650]
  code = (((A ** A) + A) * A) = [[[1],2],[[2],12],[[3],90],[[4],1040]] = [[5] = 15650]

  Cf http://hakank.org/jgap/sequence_puzzle.conf

*/
data(sequence_4,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  make_point_seq([2,12,90,1040],Data,Unknown,Vars),
  println(data=Data),
  Ops = new_map([infix=["+","-","*","/","**"]]),
  Constants = 0..1,
  MaxC = 5.


/*
  From https://www.purplemath.com/modules/nextnumb3.htm
  1 4 8 13 19 26
  19 26 ?
  Next: 34

  Solutions:
  maxCount = 5
  code = ((B + (B + 1)) - A) = [[[1,4],8],[[4,8],13],[[8,13],19],[[13,19],26]] = [[19,26] = 34]
  code = ((1 + (B * 2)) - A) = [[[1,4],8],[[4,8],13],[[8,13],19],[[13,19],26]] = [[19,26] = 34]


  Cf http://hakank.org/jgap/sequence_puzzle_recursion.conf

*/
data(sequence_6,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  make_seq([1,4,8,13,19,26],2, Data,Unknown,Vars),
  println(data=Data),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,
  MaxC = 5.


/*

  https://math.stackexchange.com/questions/1569860/how-to-find-formula-for-recursive-sequence-sum
  1 3 6 10 15 21
  15 21 ?

  Solutions:
  code = ((B + (B + 1)) - A) = [[[1,3],6],[[3,6],10],[[6,10],15],[[10,15],21]] = [[15,21] = 28]
  code = ((1 + (B * 2)) - A) = [[[1,3],6],[[3,6],10],[[6,10],15],[[10,15],21]] = [[15,21] = 28]

  Cf http://hakank.org/jgap/sequence_puzzle_recursion.conf

*/
data(sequence_7,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  make_seq([1,3,6,10,15,21],2, Data,Unknown,Vars),
  println(data=Data),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,
  MaxC = 5.


/* 
  http://hakank.org/jgap/sequence_puzzle_recursion.conf

  I'm not sure about the source of this puzzle; it's a 
  Fibonacci variant:

  3 2 5 7 12
  7 12 ?

  Solutions:
  maxCount = 1
  code = (A + B) = [[[3,2],5],[[2,5],7],[[5,7],12]] = [[7,12] = 19]
  code = (B + A) = [[[3,2],5],[[2,5],7],[[5,7],12]] = [[7,12] = 19]

*/
data(sequence_8,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  make_seq([3,2,5,7,12],2, Data,Unknown,Vars),
  println(data=Data),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,
  MaxC = 2.


/*
  Triangular numbers

  http://www.research.att.com/~njas/sequences/A000217
    a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n
 
  Solutions:
  maxCount = 5
  code = (A * ((A + 1) / 2)) = [[[1],1],[[2],3],[[3],6],[[4],10],[[5],15],[[6],21]] = [[7] = 28.0]


  Cf http://hakank.org/jgap/triangular_numbers.conf
*/
data(triangular,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  make_point_seq([1,3,6,10,15,21],Data,Unknown,Vars),
  println(data=Data),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..2,
  MaxC = 5.


/*
  https://medium.com/@themahfujur/can-you-solve-this-puzzle-only-one-in-a-thousand-people-can-solve-it-e5a57d0bff8d
  """
  1 + 4 = 5
  2 + 5 = 12
  3 + 6 = 21
  8 + 11 = ?
  """

  Note_ this is a variant of facebook_puzzle

  Solutions:
  maxCount = 2
  maxCount = 3
  code = (A + (A * B)) = [[[1,4],5],[[2,5],12],[[3,6],21]] = [[8,11] = 96]
  code = (A * (A + 4)) = [[[1,4],5],[[2,5],12],[[3,6],21]] = [[8,11] = 96]
  code = (A * (B + 1)) = [[[1,4],5],[[2,5],12],[[3,6],21]] = [[8,11] = 96]
  code = ((B + 1) * A) = [[[1,4],5],[[2,5],12],[[3,6],21]] = [[8,11] = 96]

  See equation2_b for an expanded version

*/
data(equation2,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [ [[1,4],5],
           [[2,5],12],
           [[3,6],21]
          ],
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,
  Vars = ["A","B"],
  Unknown = [8,11],  
  MaxC = 3.  

/*
  https://medium.com/@themahfujur/can-you-solve-this-puzzle-only-one-in-a-thousand-people-can-solve-it-e5a57d0bff8d
  """
  1 + 4 = 5
  2 + 5 = 12
  3 + 6 = 21
  8 + 11 = ?
  """

  This is an expanded version of equation2
  0 0 0 1 4 5
  1 4 5 2 5 12
  2 5 12 3 6 21
  3 6 21 8 11 ?

  Here we find 96 as well as 40 and 64
  Solutions:
  code = (C + (D + E)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 40]
  code = (D + (D * E)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 96]
  code = (D * (A + 5)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 64]
  code = (D * (D + 4)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 96]
  code = (D * (E + 1)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 96]    
  ...
  maxCount = 5
  code = (A + (A + (C + 5))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 32]
  code = (A + (C + (D + 4))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 36]
  code = (A + (1 + (D * E))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 92]
  code = (D + (E + (A * E))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 52]
  code = (D * ((D + E) - A)) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 128]
  code = (D * (5 + (C / E))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 55.272727272727273]
  code = (5 + (A * (D + 5))) = [[[0,0,0,1,4],5],[[1,4,5,2,5],12],[[2,5,12,3,6],21]] = [[3,6,21,8,11] = 44]


*/
data(equation2b,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [ [[0,0,0,1,4],5],
           [[1,4,5,2,5],12],
           [[2,5,12,3,6],21]
          ],
  % get_global_map().put("only_first_solution",true),          
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,
  Vars = ["A","B","C","D","E"],
  Unknown = [3,6,21,8,11],  
  MaxC = 5.  



/*
  https://medium.com/@themahfujur/17-can-you-solve-this-puzzle-many-people-fail-to-answer-this-viral-problem-78dfa1d017c6
  """
  9 = 72
  8 = 56
  7 = 42
  6 = 30
  5 = 20
  3 = ?
  """

  The "most probable" formula would be
    n * (n-1) = x
   9 * 8      = 72
   8 * 7      = 56
   7 * 6      = 42
   ...
  
  So 3 should be 3*2 = 6.
  
  It _could_ also be interpreted as
   x* (x - the number above - 2):
  3 * (5-2) = 3*3 = 9

  Solutions:
  maxCount = 3
  code = ((A * A) - A) = [[[9],72],[[8],56],[[7],42],[[6],30],[[5],20]] = [[3] = 6]
  code = (A * (A - 1)) = [[[9],72],[[8],56],[[7],42],[[6],30],[[5],20]] = [[3] = 6]

  Cf http://hakank.org/jgap/equation3.conf

*/
data(equation3,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [ [[9],72],
           [[8],56],
           [[7],42],
           [[6],30],
           [[5],20]
          ],
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,
  Vars = ["A"],
  Unknown = [3],  
  MaxC = 3.  



/*
  https://medium.com/@themahfujur/17-can-you-solve-this-puzzle-many-people-fail-to-answer-this-viral-problem-78dfa1d017c6
  """
  9 = 72
  8 = 56
  7 = 42
  6 = 30
  5 = 20
  3 = ?
  """

  Same as equation3 but as expanded representation.

  Solutions:
  maxCount = 3
  code = (B - (C + C)) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 14]
  code = (B - (C * 2)) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 14]
  code = (C * (A - 2)) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 9]
  code = ((A - 2) * C) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 9]
  code = (C * (C - 1)) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 6]
  code = ((C - 1) * C) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 6]
  maxCount = 5
  code = (((B + 2) - A) - A) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 12]
  code = ((B + (1 - C)) - A) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 13]
  code = ((1 + (C * C)) - A) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 5]
  code = (((B * C) - B) / A) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 8.0]
  code = ((C * (B - A)) / A) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 9.0]
  code = (((0 - C) - C) + B) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 14]
  code = ((C * (C + C)) - B) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = -2]
  code = (B * ((C - 1) / A)) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 8.0]
  code = (C * (C - (A - C))) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 3]
  code = (2 - (A * (2 - C))) = [[[9,72,8],56],[[8,56,7],42],[[7,42,6],30],[[6,30,5],20]] = [[5,20,3] = 7]


  Cf http://hakank.org/jgap/equation3.conf

*/
data(equation3b,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [ [[9,72,8],56],
           [[8,56,7],42],
           [[7,42,6],30],
           [[6,30,5],20]                      
          ],
  % get_global_map().put("only_first_solution",true),
  Ops = new_map([infix=["+","-","*","/"]]),
  Constants = 0..10,
  Vars = ["A","B","C"],
  Unknown = [5,20,3],
  MaxC = 5.  



/*
  Planets 

  Kepler's third law is: 
    Period^2 = Distance^3
  i.e.
    Period = sqrt(Distance)*Distance 

  (From   (https://www.r-bloggers.com/2019/04/symbolic-regression-genetic-programming-or-if-kepler-had-r/ )

  Approx value of 0.1 without sqrt: 
  code = (X ** (3 / 2)) = [[[0.72],0.61],[[1.0],1.0],[[1.52],1.84],[[5.2],11.9],[[9.529999999999999],29.399999999999999],[[19.100000000000001],83.5]] = [[19.100000000000001] = 83.473774324634448]
  code = (X * (X ** (1 / 2))) = [[[0.72],0.61],[[1.0],1.0],[[1.52],1.84],[[5.2],11.9],[[9.529999999999999],29.399999999999999],[[19.100000000000001],83.5]] = [[19.100000000000001] = 83.473774324634448]


  Using sqrt and approx value of 0.1:

  Solutions:
  maxCount = 2
  code = (sqrt(x) ** 3) = [[[0.72],0.61],[[1.0],1.0],[[1.52],1.84],[[5.2],11.9],[[9.529999999999999],29.399999999999999],[[19.100000000000001],83.5]] = [[19.100000000000001] = 83.473774324634462]
  code = (x * sqrt(x)) = [[[0.72],0.61],[[1.0],1.0],[[1.52],1.84],[[5.2],11.9],[[9.529999999999999],29.399999999999999],[[19.100000000000001],83.5]] = [[19.100000000000001] = 83.473774324634448]
  maxCount = 3
  code = sqrt((x ** 3)) = [[[0.72],0.61],[[1.0],1.0],[[1.52],1.84],[[5.2],11.9],[[9.529999999999999],29.399999999999999],[[19.100000000000001],83.5]] = [[19.100000000000001] = 83.473774324634448]
  code = (x ** (3 / 2)) = [[[0.72],0.61],[[1.0],1.0],[[1.52],1.84],[[5.2],11.9],[[9.529999999999999],29.399999999999999],[[19.100000000000001],83.5]] = [[19.100000000000001] = 83.473774324634448]

  Not too bad.

  Cf http://hakank.org/jgap/planets.conf

*/
data(planets,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [ [[0.72],0.61],
           [[1.00],1.00],
           [[1.52],1.84],
           [[5.20],11.90],
           [[9.53],29.40],
           [[19.10],83.50]
        ],
  println(data=Data),
  get_global_map().put("use_approx",0.1),
  % get_global_map().put("debug",true),  
  Ops = new_map([infix=["+","*","-","/","**"]
                 % , op1=["sqrt"]
                 ]),
  Vars = ["X"],
  Unknown = [19.10],  
  Constants = 1..3,
  MaxC = 5.


/*

  Planets, without sqrt

  Kepler's third law is: 
    Period^2 = Distance^3
  i.e.
    Period = sqrt(Distance)*Distance 

  (https://www.r-bloggers.com/2019/04/symbolic-regression-genetic-programming-or-if-kepler-had-r/ )

  Without sqrtf:

  maxCount = 2
  code = (X ** (3 / 2)) = [[[0.72],0.61],[[1.0],1.0],[[1.52],1.84],[[5.2],11.9],[[9.529999999999999],29.399999999999999],[[19.100000000000001],83.5]] = [[19.100000000000001] = 83.473774324634448]
  code = (X * (X ** (1 / 2))) = [[[0.72],0.61],[[1.0],1.0],[[1.52],1.84],[[5.2],11.9],[[9.529999999999999],29.399999999999999],[[19.100000000000001],83.5]] = [[19.100000000000001] = 83.473774324634448]

  Checking:
  Picat> X=[I**(3/2) : I in  [0.72,1.00,1.52,5.20,9.53,19.10]]     
  X = [0.610940258945177,1.0,1.873981856902569,11.857824421031035,29.419775271065546,83.473774324634448]

  Again, not too bad.

*/
data(planets_b,Data,Vars,Unknown,Ops,Constants,MaxC) :-
  Data = [ [[0.72],0.61],
           [[1.00],1.00],
           [[1.52],1.84],
           [[5.20],11.90],
           [[9.53],29.40],
           [[19.10],83.50]
        ],
  println(data=Data),
  get_global_map().put("use_approx",0.1),
  Ops = new_map([infix=["+","*","-","/","**"]]),  
  Vars = ["X"],
  Unknown = [19.10],  
  Constants = 0..3,
  MaxC = 5.


%
% User defined functions.
%

%
% To be able to use user-defined functions together with built-in functions,
% we have to redefine the operators.
%
% (Thanks to Neng-Fa Zhou for inspiration.)
%

% Built-ins
eval('+'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal+YVal.

eval('-'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal-YVal.

eval('*'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal*YVal.

eval('/'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    YVal != 0,
    Val = XVal/YVal.

eval('//'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    YVal != 0,
    Val = XVal//YVal.

eval('**'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal ** YVal.

eval('mod'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    YVal != 0,    
    Val = XVal mod YVal.

eval('rem'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    YVal != 0,
    Val = XVal rem YVal.

eval('gcd'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = gcd(XVal, YVal).

eval('^'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal ^ YVal.

eval('\\/'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal \/ YVal.

eval('/\\'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal /\ YVal.

eval('>>'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal >> YVal.

eval('<<'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = XVal << YVal.

eval('~'(X)) = Val =>
    XVal = eval(X),
    Val = ~XVal.

eval('=<'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = cond(XVal =< YVal,1,0).

eval('<'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = cond(XVal < YVal,1,0).

eval('>'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = cond(XVal > YVal,1,0).

eval('>='(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = cond(XVal >= YVal,1,0).

eval('=='(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = cond(XVal == YVal,1,0).

eval('!='(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = cond(XVal != YVal,1,0).

eval('sin'(X)) = Val =>
    XVal = eval(X),
    Val = sin(XVal).

eval('cos'(X)) = Val =>
    XVal = eval(X),
    Val = cos(XVal).

eval('exp'(X)) = Val =>
    XVal = eval(X),
    Val = exp(XVal).


eval('sqrt'(X)) = Val =>
    XVal = eval(X),
    XVal >= 0,
    Val = sqrt(XVal).


% There are many more built-in functions.
% Add when they are needed!



%
% User defined function
%
eval('odd'(X)) = Val =>
    XVal = eval(X),
    Val = cond(odd(XVal),1,0).

eval('even'(X)) = Val =>
    XVal = eval(X),
    Val = cond(even(XVal),1,0).

eval('prime'(X)) = Val =>
    XVal = eval(X),
    Val = cond(prime(XVal),1,0).

% Note: True is 1, False if everything else
eval('if_then_else'(X,Y,Z)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    ZVal = eval(Z),    
    Val = cond(XVal==1,YVal,ZVal).

eval('factorial'(X)) = Val =>
    XVal = eval(X),
    Val = factorial(XVal).

eval('!'(X)) = Val =>
    XVal = eval(X),
    Val = factorial(XVal).


% This is just a test
eval('my_sin'(X)) = Val =>
    XVal = eval(X),
    Val = sin(XVal).

% Distance between X and Y
eval('distance'(X,Y)) = Val =>
    XVal = eval(X),
    YVal = eval(Y),
    Val = sqrt(XVal**2 + YVal**2).


eval(Number) = Number, number(Number) => true.
eval(Exp) = apply(Exp). % for user-defined function
