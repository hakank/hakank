/* 

  A father with 49 gold coins in Picat.

  From MindYourDecisions:
  """
  A father has 49 gold coins. The 1st coin weighs 1 g; the 2nd coin weighs 2
  g; and so on, with the 49th coin weighing 49 g.

  He wants to give 7 coins to each of 7 sons so that every son gets coins of
  the same total weight. Can you find a way to distribute the coins?
  """

  Here are some examples:

  [1,1,1,2,2,2,3,3,3,4,4,6,4,5,6,7,5,5,5,6,7,7,7,3,1,2,4,6,6,7,7,7,5,6,4,5,6,5,4,4,3,3,2,3,2,2,1,1,1]
  1 = [1,2,3,25,47,48,49] = 175
  2 = [4,5,6,26,43,45,46] = 175
  3 = [7,8,9,24,41,42,44] = 175
  4 = [10,11,13,27,35,39,40] = 175
  5 = [14,17,18,19,33,36,38] = 175
  6 = [12,15,20,28,29,34,37] = 175
  7 = [16,21,22,23,30,31,32] = 175

  [1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,7,6,7,6,6,7,7,5,3,1,2,4,6,6,6,7,6,7,7,5,4,5,5,4,4,3,3,2,3,2,2,1,1,1]
  1 = [1,2,3,25,47,48,49] = 175
  2 = [4,5,6,26,43,45,46] = 175
  3 = [7,8,9,24,41,42,44] = 175
  4 = [10,11,12,27,36,39,40] = 175
  5 = [13,14,15,23,35,37,38] = 175
  6 = [17,19,20,28,29,30,32] = 175
  7 = [16,18,21,22,31,33,34] = 175

  [1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,6,7,7,7,3,1,2,4,5,7,7,7,6,5,6,5,4,5,6,4,4,3,3,2,3,2,2,1,1,1]
  1 = [1,2,3,25,47,48,49] = 175
  2 = [4,5,6,26,43,45,46] = 175
  3 = [7,8,9,24,41,42,44] = 175
  4 = [10,11,12,27,36,39,40] = 175
  5 = [13,14,15,28,33,35,37] = 175
  6 = [16,17,18,20,32,34,38] = 175
  7 = [19,21,22,23,29,30,31] = 175

  This is a rare case when the SMT solver seems to be the fastest solver.
  

  This program was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/

import smt.
% import sat. % a little slower than smt
% import cp. % too slow

main => go.

go ?=>
  nolog,
  Coins = 49, % number of gold coins
  Sons = 7, % number of sons

  % Total weights per son: 175g
  Weight = Coins*(Coins+1) div 2 div 7,
  println(weight=Weight),
  
  % Which coin goes to which son
  X = new_list(Coins),
  X :: 1..Sons,
  
  foreach(S in 1..Sons)
    % Each son gets 7 coins
    % sum([X[I] #= S : I in 1..Coins]) #= 7,
    count(S,X,#=,7),
    % Each son get the same weight of coins
    sum([I*(X[I] #= S) : I in 1..Coins]) #= Weight
  end,

  % Symmetry breaking
  foreach(C in 1..Sons)
    X[C] #<= C
  end,
  
  solve(X),
  println(X),
  foreach(S in 1..Sons)
    T = [C : C in 1..Coins, X[C] == S],
    println(S=T=T.sum)
  end,
  nl,
  fail,

  nl.
go => true.

/*
  From MindYourDecisions:
  """
  The key lies in an ancient mathematical pattern: magic squares! A 7×7
  magic square has every row equaling the same magic sum, and every
  column also equals the same magic sum. 
  """

  Here are some solutions:
  [5,1,24,45,41,46,13] = 175
  [42,29,2,7,27,21,47] = 175
  [11,36,16,44,6,32,30] = 175
  [31,15,48,33,25,3,20] = 175
  [17,40,39,18,43,14,4] = 175
  [34,28,8,9,10,37,49] = 175
  [35,26,38,19,23,22,12] = 175

  [7,12,38,48,13,36,21] = 175
  [35,28,6,20,46,14,26] = 175
  [19,39,18,41,25,17,16] = 175
  [5,9,47,3,29,37,45] = 175
  [27,34,23,2,43,24,22] = 175
  [42,49,10,30,11,32,1] = 175
  [40,4,33,31,8,15,44] = 175

  [23,12,32,27,28,6,47] = 175
  [37,10,2,38,30,41,17] = 175
  [16,43,13,42,3,40,18] = 175
  [24,35,44,4,45,8,15] = 175
  [19,5,25,9,48,33,36] = 175
  [22,21,39,29,7,46,11] = 175
  [34,49,20,26,14,1,31] = 175

  ...

*/
go2 ?=>
  nolog,
  N = 7,
  NN = N*N,
  Sum = N*(NN+1) div 2,% magical sum
  println(sum=Sum),
  
  X = new_array(N,N),
  X :: 1..NN,

  all_different(X.vars()),

  foreach(I in 1..N)
     Sum #= sum([T : J in 1..N, T = X[I,J]]), % rows
     Sum #= sum([T : J in 1..N, T = X[J,I]])  % column
  end,

  % diagonal sums
  Sum #= sum([X[I,I] : I in 1..N]),
  Sum #= sum([X[I,N-I+1] : I in 1..N]),

  % Symmetry breaking
  % Frénicle standard form
  X[1,1] #= min([X[1,1], X[1,N], X[N,1], X[N,N]]),
  X[1,2] #< X[2,1],

  solve(X),
  foreach(Row in X)
    println(Row.to_list=Row.sum)
  end,
  nl,
  fail,

  nl.
go2 => true.