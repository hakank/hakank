/* 

  Sum to 100 problem (Rosetta Code) in Picat.

  http://rosettacode.org/wiki/Sum_to_100
  """
  Find solutions to the   sum to one hundred   puzzle.

  Add (insert) the mathematical operators + or â”€ (plus or minus) before any of the digits in the
  decimal numeric string "123456789" such that the resulting mathematical expression adds up to a
  particular sum (in this iconic case, 100).

  Example:

           123 + 4 - 5 + 67 - 89   =   100   

  Show all output here.


  - Show all solutions that sum to   100
  - Show the sum that has the maximum   number   of solutions   (from zero to infinity*)
  - Show the lowest positive sum that   can't   be expressed   (has no solutions), using the rules for this task
  - Show the ten highest numbers that can be expressed using the rules for this task   (extra credit)


  An example of a sum that can't be expressed (within the rules of this task) is:   5074
  which, of course, is not the lowest positive sum that can't be expressed.


  *   (where   infinity   would be a relatively small   123,456,789)
  """

  This Picat model was created by Hakan Kjellerstrand, hakank@gmail.com
  See also my Picat page: http://www.hakank.org/picat/

*/


import util.
import cp.


main => go.

% Show all solutions that sum to 100
go => 
  clear(get_global_map(tt)),
  Goal = 100,
  L = 1..9,
  All = find_all(SS,find_goal(L,Goal,SS)).sort_remove_dups(),
  foreach(E in All) println(E) end,
  println(len=All.len),

  nl.

go2 => 
   L = 1..9,
   Goal = 100,
   find_goal2(L,Goal),
   nl.

%  Show the lowest positive sum that can't be expressed (has no solutions), using the rules for this task.
go3 => 

  N = 200,
  L = 1..9,
  Found = false,
  while (Found == false) do
     clear(get_global_map(tt)), 
     println(testing=N),
     if find_goal(L,_Goal,_SS) then
        Found := N
     end,
     N := N + 1
  end,
  println(found=Found),
  nl.

% Find first N not possible to create with these rules
go4 =>
   Found = false,
   foreach(N in 1..10000,Found == false)
     % println(n=N),
     % find_goal/3 use get_global_map(tt) so we clear it first     
     clear(get_global_map(tt)), 
     % if All = findall(SS,find_goal(1..9,N,SS)) then
     if find_goal(1..9,N,_SS) then
       % println(SS)
       true
     else
       Found := N
     end%,
     % nl
   end,
   println(found=Found),
   nl.


% Find all solutions for N in 1..100
go5 =>
   foreach(N in 1..100)
     println(n=N),
     % find_goal/3 use get_global_map(tt) so we clear it first     
     clear(get_global_map(tt)), 
     if All = findall(SS,find_goal(1..9,N,SS)) then
       println(All),
       println(len=All.len),
       nl
     else
       println(not_ok)
     end,
     nl
   end,
   nl.


get_all_segments(L) = findall(S,get_segment(L,S)).remove_dups().

get_segment(L,S) =>
  N = L.len,
  % find all increasing segments
  Segments = new_list(N),
  Segments :: 1..N,
  increasing(Segments),
  solve([split],Segments),
  % split into the segments and collect the digits into numbers (as strings)
  S = [ [L[J].to_string() : J in 1..N, Segments[J] = I].join('') : I in Segments.remove_dups()].


find_goal(L,Goal, SSRes) =>
  N = L.len,

  % find all increasing segments
  Segments = new_list(N),
  Segments :: 1..N,
  increasing(Segments),
  solve([split],Segments),

  % split into the segments and collect the digits into numbers (as strings)
  S = [ [L[J].to_string() : J in 1..N, Segments[J] = I].join('') : I in Segments.remove_dups()],
  % remove duplicates
  Map = get_global_map(tt),
  if Map.has_key(S) then
    fail
  end,
  Map.put(S,1),
  Len = S.len,
  % println(s=S),

  % we must have at least two segments
  Len > 1,

  % find the operators
  Ops = ["+","-"],
  OpsLen = Len,
  OpsSep = new_list(OpsLen),
  foreach(I in 1..OpsLen)
    member(Op,Ops),
    OpsSep[I] := Op
  end,

  % create the complete string
  SS = [OpsSep[I] ++ S[I]  : I in 1..OpsLen].join(''),
  Goal == parse_term(SS).apply(),
  SSRes = SS.


find_goal2(L,Goal) =>
  Map = get_global_map(),
  Segments = get_all_segments(L).remove_dups(),
  foreach(Segment in Segments, Segment.len > 1) 
    if Map.has_key(Segment) then
       fail
    end,
    Map.put(Segment,1),
    Len = Segment.len,
    Ops = ["+","-"],
    OpsLen = Len,
    OpsSep = new_list(OpsLen),
    foreach(I in 1..OpsLen)
      member(Op,Ops),
      OpsSep[I] := Op
    end,
    % create the complete string
    SS = [OpsSep[I] ++ Segment[I].to_string()  : I in 1..OpsLen].join(''),
    if Goal == parse_term(SS).apply() then
    % if Goal == eval(SS) then
      println(SS)
    end
  end,
  fail,
  nl.

